{"id":"YjFH","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\node_modules\\pako\\package.json","includedInParent":true,"mtime":1598465925143}],"generated":{"js":"var $YjFH$export$Buf8,\n    $YjFH$export$Buf16,\n    $YjFH$export$Buf32,\n    $YjFH$exports = {};\nvar $YjFH$var$TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';\n\nfunction $YjFH$var$_has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nvar $YjFH$export$assign = function (obj\n/*from1, from2, from3, ...*/\n) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  while (sources.length) {\n    var source = sources.shift();\n\n    if (!source) {\n      continue;\n    }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if ($YjFH$var$_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n$YjFH$exports.assign = $YjFH$export$assign; // reduce buffer size, avoiding mem copy\n\nvar $YjFH$export$shrinkBuf = function (buf, size) {\n  if (buf.length === size) {\n    return buf;\n  }\n\n  if (buf.subarray) {\n    return buf.subarray(0, size);\n  }\n\n  buf.length = size;\n  return buf;\n};\n\n$YjFH$exports.shrinkBuf = $YjFH$export$shrinkBuf;\nvar $YjFH$var$fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    } // Fallback to ordinary array\n\n\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result; // calculate data length\n\n    len = 0;\n\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    } // join chunks\n\n\n    result = new Uint8Array(len);\n    pos = 0;\n\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\nvar $YjFH$var$fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n}; // Enable/Disable typed arrays use, for testing\n//\n\nvar $YjFH$export$setTyped = function (on) {\n  if (on) {\n    $YjFH$export$Buf8 = Uint8Array\n    $YjFH$exports.Buf8 = $YjFH$export$Buf8;\n    $YjFH$export$Buf16 = Uint16Array\n    $YjFH$exports.Buf16 = $YjFH$export$Buf16;\n    $YjFH$export$Buf32 = Int32Array\n    $YjFH$exports.Buf32 = $YjFH$export$Buf32;\n    $YjFH$exports.assign($YjFH$exports, $YjFH$var$fnTyped);\n  } else {\n    $YjFH$export$Buf8 = Array\n    $YjFH$exports.Buf8 = $YjFH$export$Buf8;\n    $YjFH$export$Buf16 = Array\n    $YjFH$exports.Buf16 = $YjFH$export$Buf16;\n    $YjFH$export$Buf32 = Array\n    $YjFH$exports.Buf32 = $YjFH$export$Buf32;\n    $YjFH$exports.assign($YjFH$exports, $YjFH$var$fnUntyped);\n  }\n};\n\n$YjFH$exports.setTyped = $YjFH$export$setTyped;\n$YjFH$exports.setTyped($YjFH$var$TYPED_OK);"},"sourceMaps":null,"error":null,"hash":"b338823544b27d8f932457370443312f","cacheData":{"env":{},"imports":{},"exports":{"assign":"$YjFH$export$assign","shrinkBuf":"$YjFH$export$shrinkBuf","setTyped":"$YjFH$export$setTyped","Buf8":"$YjFH$export$Buf8","Buf16":"$YjFH$export$Buf16","Buf32":"$YjFH$export$Buf32"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}