{"id":"LVHm","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randomfill\\package.json","includedInParent":true,"mtime":1598465897865},{"name":"safe-buffer","loc":{"line":6,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randomfill\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\safe-buffer\\index.js"},{"name":"randombytes","loc":{"line":7,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randomfill\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randombytes\\browser.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randomfill\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"\nvar $LVHm$var$process = $parcel$require(\"LVHm\", \"process\");\nvar $LVHm$export$randomFill,\n    $LVHm$export$randomFillSync,\n    $LVHm$exports = {};\n\nfunction $LVHm$var$oldBrowser() {\n  throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11');\n}\n\nvar $LVHm$var$safeBuffer = $parcel$require(\"LVHm\", \"safe-buffer\");\nvar $LVHm$var$randombytes = $parcel$require(\"LVHm\", \"randombytes\");\nvar $LVHm$var$Buffer = $LVHm$var$safeBuffer.Buffer;\nvar $LVHm$var$kBufferMaxLength = $LVHm$var$safeBuffer.kMaxLength;\nvar $LVHm$var$crypto = $parcel$global.crypto || $parcel$global.msCrypto;\nvar $LVHm$var$kMaxUint32 = Math.pow(2, 32) - 1;\n\nfunction $LVHm$var$assertOffset(offset, length) {\n  if (typeof offset !== 'number' || offset !== offset) {\n    // eslint-disable-line no-self-compare\n    throw new TypeError('offset must be a number');\n  }\n\n  if (offset > $LVHm$var$kMaxUint32 || offset < 0) {\n    throw new TypeError('offset must be a uint32');\n  }\n\n  if (offset > $LVHm$var$kBufferMaxLength || offset > length) {\n    throw new RangeError('offset out of range');\n  }\n}\n\nfunction $LVHm$var$assertSize(size, offset, length) {\n  if (typeof size !== 'number' || size !== size) {\n    // eslint-disable-line no-self-compare\n    throw new TypeError('size must be a number');\n  }\n\n  if (size > $LVHm$var$kMaxUint32 || size < 0) {\n    throw new TypeError('size must be a uint32');\n  }\n\n  if (size + offset > length || size > $LVHm$var$kBufferMaxLength) {\n    throw new RangeError('buffer too small');\n  }\n}\n\nif ($LVHm$var$crypto && $LVHm$var$crypto.getRandomValues || !true) {\n  $LVHm$export$randomFill = $LVHm$var$randomFill\n  $LVHm$exports.randomFill = $LVHm$export$randomFill;\n  $LVHm$export$randomFillSync = $LVHm$var$randomFillSync\n  $LVHm$exports.randomFillSync = $LVHm$export$randomFillSync;\n} else {\n  $LVHm$export$randomFill = $LVHm$var$oldBrowser\n  $LVHm$exports.randomFill = $LVHm$export$randomFill;\n  $LVHm$export$randomFillSync = $LVHm$var$oldBrowser\n  $LVHm$exports.randomFillSync = $LVHm$export$randomFillSync;\n}\n\nfunction $LVHm$var$randomFill(buf, offset, size, cb) {\n  if (!$LVHm$var$Buffer.isBuffer(buf) && !(buf instanceof $parcel$global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n  }\n\n  if (typeof offset === 'function') {\n    cb = offset;\n    offset = 0;\n    size = buf.length;\n  } else if (typeof size === 'function') {\n    cb = size;\n    size = buf.length - offset;\n  } else if (typeof cb !== 'function') {\n    throw new TypeError('\"cb\" argument must be a function');\n  }\n\n  $LVHm$var$assertOffset(offset, buf.length);\n  $LVHm$var$assertSize(size, offset, buf.length);\n  return $LVHm$var$actualFill(buf, offset, size, cb);\n}\n\nfunction $LVHm$var$actualFill(buf, offset, size, cb) {\n  if (true) {\n    var ourBuf = buf.buffer;\n    var uint = new Uint8Array(ourBuf, offset, size);\n    $LVHm$var$crypto.getRandomValues(uint);\n\n    if (cb) {\n      $LVHm$var$process.nextTick(function () {\n        cb(null, buf);\n      });\n      return;\n    }\n\n    return buf;\n  }\n\n  if (cb) {\n    $LVHm$var$randombytes(size, function (err, bytes) {\n      if (err) {\n        return cb(err);\n      }\n\n      bytes.copy(buf, offset);\n      cb(null, buf);\n    });\n    return;\n  }\n\n  var bytes = $LVHm$var$randombytes(size);\n  bytes.copy(buf, offset);\n  return buf;\n}\n\nfunction $LVHm$var$randomFillSync(buf, offset, size) {\n  if (typeof offset === 'undefined') {\n    offset = 0;\n  }\n\n  if (!$LVHm$var$Buffer.isBuffer(buf) && !(buf instanceof $parcel$global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n  }\n\n  $LVHm$var$assertOffset(offset, buf.length);\n  if (size === undefined) size = buf.length - offset;\n  $LVHm$var$assertSize(size, offset, buf.length);\n  return $LVHm$var$actualFill(buf, offset, size);\n}"},"sourceMaps":null,"error":null,"hash":"b8c8acfa4c40680c88ad50ccefc75130","cacheData":{"env":{},"imports":{"$require$safe-buffer":["safe-buffer","*"],"$require$randombytes":["randombytes","*"],"$require$process":["process","*"]},"exports":{"randomFill":"$LVHm$export$randomFill","randomFillSync":"$LVHm$export$randomFillSync"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}