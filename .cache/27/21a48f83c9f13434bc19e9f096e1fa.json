{"id":"Opjp","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\package.json","includedInParent":true,"mtime":1598465894919},{"name":"http-errors","loc":{"line":15,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\http-errors\\index.js"},{"name":"debug","loc":{"line":16,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\debug\\src\\browser.js"},{"name":"depd","loc":{"line":17,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\depd\\lib\\browser\\index.js"},{"name":"destroy","loc":{"line":18,"column":22},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\destroy\\index.js"},{"name":"encodeurl","loc":{"line":19,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\encodeurl\\index.js"},{"name":"escape-html","loc":{"line":20,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\escape-html\\index.js"},{"name":"etag","loc":{"line":21,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\etag\\index.js"},{"name":"fresh","loc":{"line":22,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\fresh\\index.js"},{"name":"fs","loc":{"line":23,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parcel-bundler\\src\\builtins\\_empty.js"},{"name":"mime","loc":{"line":24,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\mime\\mime.js"},{"name":"ms","loc":{"line":25,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\ms\\index.js"},{"name":"on-finished","loc":{"line":26,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\on-finished\\index.js"},{"name":"range-parser","loc":{"line":27,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\range-parser\\index.js"},{"name":"path","loc":{"line":28,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\path-browserify\\index.js"},{"name":"statuses","loc":{"line":29,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\statuses\\index.js"},{"name":"stream","loc":{"line":30,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-browserify\\index.js"},{"name":"util","loc":{"line":31,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\util\\util.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\send\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $Opjp$exports = {};\nvar $Opjp$var$Buffer = $parcel$require(\"Opjp\", \"buffer\").Buffer;\n\n/**\n * Module dependencies.\n * @private\n */\nvar $Opjp$var$createError = $parcel$require(\"Opjp\", \"http-errors\");\nvar $Opjp$var$debug = $parcel$require(\"Opjp\", \"debug\")('send');\nvar $Opjp$var$deprecate = $parcel$require(\"Opjp\", \"depd\")('send');\nvar $Opjp$var$destroy = $parcel$require(\"Opjp\", \"destroy\");\nvar $Opjp$var$encodeUrl = $parcel$require(\"Opjp\", \"encodeurl\");\nvar $Opjp$var$escapeHtml = $parcel$require(\"Opjp\", \"escape-html\");\nvar $Opjp$var$etag = $parcel$require(\"Opjp\", \"etag\");\nvar $Opjp$var$fresh = $parcel$require(\"Opjp\", \"fresh\");\nvar $Opjp$var$fs = $parcel$require(\"Opjp\", \"fs\");\nvar $Opjp$var$mime = $parcel$require(\"Opjp\", \"mime\");\nvar $Opjp$var$ms = $parcel$require(\"Opjp\", \"ms\");\nvar $Opjp$var$onFinished = $parcel$require(\"Opjp\", \"on-finished\");\nvar $Opjp$var$parseRange = $parcel$require(\"Opjp\", \"range-parser\");\nvar $Opjp$var$path = $parcel$require(\"Opjp\", \"path\");\nvar $Opjp$var$statuses = $parcel$require(\"Opjp\", \"statuses\");\nvar $Opjp$var$Stream = $parcel$require(\"Opjp\", \"stream\");\nvar $Opjp$var$util = $parcel$require(\"Opjp\", \"util\");\n/**\n * Path function references.\n * @private\n */\n\nvar $Opjp$var$extname = $Opjp$var$path.extname;\nvar $Opjp$var$join = $Opjp$var$path.join;\nvar $Opjp$var$normalize = $Opjp$var$path.normalize;\nvar $Opjp$var$resolve = $Opjp$var$path.resolve;\nvar $Opjp$var$sep = $Opjp$var$path.sep;\n/**\n * Regular expression for identifying a bytes Range header.\n * @private\n */\n\nvar $Opjp$var$BYTES_RANGE_REGEXP = /^ *bytes=/;\n/**\n * Maximum value allowed for the max age.\n * @private\n */\n\nvar $Opjp$var$MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year\n\n/**\n * Regular expression to match a path with a directory up component.\n * @private\n */\n\nvar $Opjp$var$UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/;\n/**\n * Module exports.\n * @public\n */\n\n$Opjp$exports = $Opjp$var$send;\n$Opjp$exports.mime = $Opjp$var$mime;\n/**\n * Return a `SendStream` for `req` and `path`.\n *\n * @param {object} req\n * @param {string} path\n * @param {object} [options]\n * @return {SendStream}\n * @public\n */\n\nfunction $Opjp$var$send(req, path, options) {\n  return new $Opjp$var$SendStream(req, path, options);\n}\n/**\n * Initialize a `SendStream` with the given `path`.\n *\n * @param {Request} req\n * @param {String} path\n * @param {object} [options]\n * @private\n */\n\n\nfunction $Opjp$var$SendStream(req, path, options) {\n  $Opjp$var$Stream.call(this);\n  var opts = options || {};\n  this.options = opts;\n  this.path = path;\n  this.req = req;\n  this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;\n  this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;\n  this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;\n  this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';\n\n  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {\n    throw new TypeError('dotfiles option must be \"allow\", \"deny\", or \"ignore\"');\n  }\n\n  this._hidden = Boolean(opts.hidden);\n\n  if (opts.hidden !== undefined) {\n    $Opjp$var$deprecate('hidden: use dotfiles: \\'' + (this._hidden ? 'allow' : 'ignore') + '\\' instead');\n  } // legacy support\n\n\n  if (opts.dotfiles === undefined) {\n    this._dotfiles = undefined;\n  }\n\n  this._extensions = opts.extensions !== undefined ? $Opjp$var$normalizeList(opts.extensions, 'extensions option') : [];\n  this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;\n  this._index = opts.index !== undefined ? $Opjp$var$normalizeList(opts.index, 'index option') : ['index.html'];\n  this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;\n  this._maxage = opts.maxAge || opts.maxage;\n  this._maxage = typeof this._maxage === 'string' ? $Opjp$var$ms(this._maxage) : Number(this._maxage);\n  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), $Opjp$var$MAX_MAXAGE) : 0;\n  this._root = opts.root ? $Opjp$var$resolve(opts.root) : null;\n\n  if (!this._root && opts.from) {\n    this.from(opts.from);\n  }\n}\n/**\n * Inherits from `Stream`.\n */\n\n\n$Opjp$var$util.inherits($Opjp$var$SendStream, $Opjp$var$Stream);\n/**\n * Enable or disable etag generation.\n *\n * @param {Boolean} val\n * @return {SendStream}\n * @api public\n */\n\n$Opjp$var$SendStream.prototype.etag = $Opjp$var$deprecate.function(function etag(val) {\n  this._etag = Boolean(val);\n  $Opjp$var$debug('etag %s', this._etag);\n  return this;\n}, 'send.etag: pass etag as option');\n/**\n * Enable or disable \"hidden\" (dot) files.\n *\n * @param {Boolean} path\n * @return {SendStream}\n * @api public\n */\n\n$Opjp$var$SendStream.prototype.hidden = $Opjp$var$deprecate.function(function hidden(val) {\n  this._hidden = Boolean(val);\n  this._dotfiles = undefined;\n  $Opjp$var$debug('hidden %s', this._hidden);\n  return this;\n}, 'send.hidden: use dotfiles option');\n/**\n * Set index `paths`, set to a falsy\n * value to disable index support.\n *\n * @param {String|Boolean|Array} paths\n * @return {SendStream}\n * @api public\n */\n\n$Opjp$var$SendStream.prototype.index = $Opjp$var$deprecate.function(function index(paths) {\n  var index = !paths ? [] : $Opjp$var$normalizeList(paths, 'paths argument');\n  $Opjp$var$debug('index %o', paths);\n  this._index = index;\n  return this;\n}, 'send.index: pass index as option');\n/**\n * Set root `path`.\n *\n * @param {String} path\n * @return {SendStream}\n * @api public\n */\n\n$Opjp$var$SendStream.prototype.root = function root(path) {\n  this._root = $Opjp$var$resolve(String(path));\n  $Opjp$var$debug('root %s', this._root);\n  return this;\n};\n\n$Opjp$var$SendStream.prototype.from = $Opjp$var$deprecate.function($Opjp$var$SendStream.prototype.root, 'send.from: pass root as option');\n$Opjp$var$SendStream.prototype.root = $Opjp$var$deprecate.function($Opjp$var$SendStream.prototype.root, 'send.root: pass root as option');\n/**\n * Set max-age to `maxAge`.\n *\n * @param {Number} maxAge\n * @return {SendStream}\n * @api public\n */\n\n$Opjp$var$SendStream.prototype.maxage = $Opjp$var$deprecate.function(function maxage(maxAge) {\n  this._maxage = typeof maxAge === 'string' ? $Opjp$var$ms(maxAge) : Number(maxAge);\n  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), $Opjp$var$MAX_MAXAGE) : 0;\n  $Opjp$var$debug('max-age %d', this._maxage);\n  return this;\n}, 'send.maxage: pass maxAge as option');\n/**\n * Emit error with `status`.\n *\n * @param {number} status\n * @param {Error} [err]\n * @private\n */\n\n$Opjp$var$SendStream.prototype.error = function error(status, err) {\n  // emit if listeners instead of responding\n  if ($Opjp$var$hasListeners(this, 'error')) {\n    return this.emit('error', $Opjp$var$createError(status, err, {\n      expose: false\n    }));\n  }\n\n  var res = this.res;\n  var msg = $Opjp$var$statuses[status] || String(status);\n  var doc = $Opjp$var$createHtmlDocument('Error', $Opjp$var$escapeHtml(msg)); // clear existing headers\n\n  $Opjp$var$clearHeaders(res); // add error headers\n\n  if (err && err.headers) {\n    $Opjp$var$setHeaders(res, err.headers);\n  } // send basic response\n\n\n  res.statusCode = status;\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8');\n  res.setHeader('Content-Length', $Opjp$var$Buffer.byteLength(doc));\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.end(doc);\n};\n/**\n * Check if the pathname ends with \"/\".\n *\n * @return {boolean}\n * @private\n */\n\n\n$Opjp$var$SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {\n  return this.path[this.path.length - 1] === '/';\n};\n/**\n * Check if this is a conditional GET request.\n *\n * @return {Boolean}\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.isConditionalGET = function isConditionalGET() {\n  return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];\n};\n/**\n * Check if the request preconditions failed.\n *\n * @return {boolean}\n * @private\n */\n\n\n$Opjp$var$SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {\n  var req = this.req;\n  var res = this.res; // if-match\n\n  var match = req.headers['if-match'];\n\n  if (match) {\n    var etag = res.getHeader('ETag');\n    return !etag || match !== '*' && $Opjp$var$parseTokenList(match).every(function (match) {\n      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;\n    });\n  } // if-unmodified-since\n\n\n  var unmodifiedSince = $Opjp$var$parseHttpDate(req.headers['if-unmodified-since']);\n\n  if (!isNaN(unmodifiedSince)) {\n    var lastModified = $Opjp$var$parseHttpDate(res.getHeader('Last-Modified'));\n    return isNaN(lastModified) || lastModified > unmodifiedSince;\n  }\n\n  return false;\n};\n/**\n * Strip content-* header fields.\n *\n * @private\n */\n\n\n$Opjp$var$SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {\n  var res = this.res;\n  var headers = $Opjp$var$getHeaderNames(res);\n\n  for (var i = 0; i < headers.length; i++) {\n    var header = headers[i];\n\n    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {\n      res.removeHeader(header);\n    }\n  }\n};\n/**\n * Respond with 304 not modified.\n *\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.notModified = function notModified() {\n  var res = this.res;\n  $Opjp$var$debug('not modified');\n  this.removeContentHeaderFields();\n  res.statusCode = 304;\n  res.end();\n};\n/**\n * Raise error that headers already sent.\n *\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.headersAlreadySent = function headersAlreadySent() {\n  var err = new Error('Can\\'t set headers after they are sent.');\n  $Opjp$var$debug('headers already sent');\n  this.error(500, err);\n};\n/**\n * Check if the request is cacheable, aka\n * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).\n *\n * @return {Boolean}\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.isCachable = function isCachable() {\n  var statusCode = this.res.statusCode;\n  return statusCode >= 200 && statusCode < 300 || statusCode === 304;\n};\n/**\n * Handle stat() error.\n *\n * @param {Error} error\n * @private\n */\n\n\n$Opjp$var$SendStream.prototype.onStatError = function onStatError(error) {\n  switch (error.code) {\n    case 'ENAMETOOLONG':\n    case 'ENOENT':\n    case 'ENOTDIR':\n      this.error(404, error);\n      break;\n\n    default:\n      this.error(500, error);\n      break;\n  }\n};\n/**\n * Check if the cache is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.isFresh = function isFresh() {\n  return $Opjp$var$fresh(this.req.headers, {\n    'etag': this.res.getHeader('ETag'),\n    'last-modified': this.res.getHeader('Last-Modified')\n  });\n};\n/**\n * Check if the range is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.isRangeFresh = function isRangeFresh() {\n  var ifRange = this.req.headers['if-range'];\n\n  if (!ifRange) {\n    return true;\n  } // if-range as etag\n\n\n  if (ifRange.indexOf('\"') !== -1) {\n    var etag = this.res.getHeader('ETag');\n    return Boolean(etag && ifRange.indexOf(etag) !== -1);\n  } // if-range as modified date\n\n\n  var lastModified = this.res.getHeader('Last-Modified');\n  return $Opjp$var$parseHttpDate(lastModified) <= $Opjp$var$parseHttpDate(ifRange);\n};\n/**\n * Redirect to path.\n *\n * @param {string} path\n * @private\n */\n\n\n$Opjp$var$SendStream.prototype.redirect = function redirect(path) {\n  var res = this.res;\n\n  if ($Opjp$var$hasListeners(this, 'directory')) {\n    this.emit('directory', res, path);\n    return;\n  }\n\n  if (this.hasTrailingSlash()) {\n    this.error(403);\n    return;\n  }\n\n  var loc = $Opjp$var$encodeUrl($Opjp$var$collapseLeadingSlashes(this.path + '/'));\n  var doc = $Opjp$var$createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + $Opjp$var$escapeHtml(loc) + '\">' + $Opjp$var$escapeHtml(loc) + '</a>'); // redirect\n\n  res.statusCode = 301;\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8');\n  res.setHeader('Content-Length', $Opjp$var$Buffer.byteLength(doc));\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('Location', loc);\n  res.end(doc);\n};\n/**\n * Pipe to `res.\n *\n * @param {Stream} res\n * @return {Stream} res\n * @api public\n */\n\n\n$Opjp$var$SendStream.prototype.pipe = function pipe(res) {\n  // root path\n  var root = this._root; // references\n\n  this.res = res; // decode the path\n\n  var path = $Opjp$var$decode(this.path);\n\n  if (path === -1) {\n    this.error(400);\n    return res;\n  } // null byte(s)\n\n\n  if (~path.indexOf('\\0')) {\n    this.error(400);\n    return res;\n  }\n\n  var parts;\n\n  if (root !== null) {\n    // normalize\n    if (path) {\n      path = $Opjp$var$normalize('.' + $Opjp$var$sep + path);\n    } // malicious path\n\n\n    if ($Opjp$var$UP_PATH_REGEXP.test(path)) {\n      $Opjp$var$debug('malicious path \"%s\"', path);\n      this.error(403);\n      return res;\n    } // explode path parts\n\n\n    parts = path.split($Opjp$var$sep); // join / normalize from optional root dir\n\n    path = $Opjp$var$normalize($Opjp$var$join(root, path));\n    root = $Opjp$var$normalize(root + $Opjp$var$sep);\n  } else {\n    // \"..\" is malicious without \"root\"\n    if ($Opjp$var$UP_PATH_REGEXP.test(path)) {\n      $Opjp$var$debug('malicious path \"%s\"', path);\n      this.error(403);\n      return res;\n    } // explode path parts\n\n\n    parts = $Opjp$var$normalize(path).split($Opjp$var$sep); // resolve the path\n\n    path = $Opjp$var$resolve(path);\n  } // dotfile handling\n\n\n  if ($Opjp$var$containsDotFile(parts)) {\n    var access = this._dotfiles; // legacy support\n\n    if (access === undefined) {\n      access = parts[parts.length - 1][0] === '.' ? this._hidden ? 'allow' : 'ignore' : 'allow';\n    }\n\n    $Opjp$var$debug('%s dotfile \"%s\"', access, path);\n\n    switch (access) {\n      case 'allow':\n        break;\n\n      case 'deny':\n        this.error(403);\n        return res;\n\n      case 'ignore':\n      default:\n        this.error(404);\n        return res;\n    }\n  } // index file support\n\n\n  if (this._index.length && this.hasTrailingSlash()) {\n    this.sendIndex(path);\n    return res;\n  }\n\n  this.sendFile(path);\n  return res;\n};\n/**\n * Transfer `path`.\n *\n * @param {String} path\n * @api public\n */\n\n\n$Opjp$var$SendStream.prototype.send = function send(path, stat) {\n  var len = stat.size;\n  var options = this.options;\n  var opts = {};\n  var res = this.res;\n  var req = this.req;\n  var ranges = req.headers.range;\n  var offset = options.start || 0;\n\n  if ($Opjp$var$headersSent(res)) {\n    // impossible to send now\n    this.headersAlreadySent();\n    return;\n  }\n\n  $Opjp$var$debug('pipe \"%s\"', path); // set header fields\n\n  this.setHeader(path, stat); // set content-type\n\n  this.type(path); // conditional GET support\n\n  if (this.isConditionalGET()) {\n    if (this.isPreconditionFailure()) {\n      this.error(412);\n      return;\n    }\n\n    if (this.isCachable() && this.isFresh()) {\n      this.notModified();\n      return;\n    }\n  } // adjust len to start/end options\n\n\n  len = Math.max(0, len - offset);\n\n  if (options.end !== undefined) {\n    var bytes = options.end - offset + 1;\n    if (len > bytes) len = bytes;\n  } // Range support\n\n\n  if (this._acceptRanges && $Opjp$var$BYTES_RANGE_REGEXP.test(ranges)) {\n    // parse\n    ranges = $Opjp$var$parseRange(len, ranges, {\n      combine: true\n    }); // If-Range support\n\n    if (!this.isRangeFresh()) {\n      $Opjp$var$debug('range stale');\n      ranges = -2;\n    } // unsatisfiable\n\n\n    if (ranges === -1) {\n      $Opjp$var$debug('range unsatisfiable'); // Content-Range\n\n      res.setHeader('Content-Range', $Opjp$var$contentRange('bytes', len)); // 416 Requested Range Not Satisfiable\n\n      return this.error(416, {\n        headers: {\n          'Content-Range': res.getHeader('Content-Range')\n        }\n      });\n    } // valid (syntactically invalid/multiple ranges are treated as a regular response)\n\n\n    if (ranges !== -2 && ranges.length === 1) {\n      $Opjp$var$debug('range %j', ranges); // Content-Range\n\n      res.statusCode = 206;\n      res.setHeader('Content-Range', $Opjp$var$contentRange('bytes', len, ranges[0])); // adjust for requested range\n\n      offset += ranges[0].start;\n      len = ranges[0].end - ranges[0].start + 1;\n    }\n  } // clone options\n\n\n  for (var prop in options) {\n    opts[prop] = options[prop];\n  } // set read options\n\n\n  opts.start = offset;\n  opts.end = Math.max(offset, offset + len - 1); // content-length\n\n  res.setHeader('Content-Length', len); // HEAD support\n\n  if (req.method === 'HEAD') {\n    res.end();\n    return;\n  }\n\n  this.stream(path, opts);\n};\n/**\n * Transfer file for `path`.\n *\n * @param {String} path\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.sendFile = function sendFile(path) {\n  var i = 0;\n  var self = this;\n  $Opjp$var$debug('stat \"%s\"', path);\n  $Opjp$var$fs.stat(path, function onstat(err, stat) {\n    if (err && err.code === 'ENOENT' && !$Opjp$var$extname(path) && path[path.length - 1] !== $Opjp$var$sep) {\n      // not found, check extensions\n      return next(err);\n    }\n\n    if (err) return self.onStatError(err);\n    if (stat.isDirectory()) return self.redirect(path);\n    self.emit('file', path, stat);\n    self.send(path, stat);\n  });\n\n  function next(err) {\n    if (self._extensions.length <= i) {\n      return err ? self.onStatError(err) : self.error(404);\n    }\n\n    var p = path + '.' + self._extensions[i++];\n    $Opjp$var$debug('stat \"%s\"', p);\n    $Opjp$var$fs.stat(p, function (err, stat) {\n      if (err) return next(err);\n      if (stat.isDirectory()) return next();\n      self.emit('file', p, stat);\n      self.send(p, stat);\n    });\n  }\n};\n/**\n * Transfer index for `path`.\n *\n * @param {String} path\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.sendIndex = function sendIndex(path) {\n  var i = -1;\n  var self = this;\n\n  function next(err) {\n    if (++i >= self._index.length) {\n      if (err) return self.onStatError(err);\n      return self.error(404);\n    }\n\n    var p = $Opjp$var$join(path, self._index[i]);\n    $Opjp$var$debug('stat \"%s\"', p);\n    $Opjp$var$fs.stat(p, function (err, stat) {\n      if (err) return next(err);\n      if (stat.isDirectory()) return next();\n      self.emit('file', p, stat);\n      self.send(p, stat);\n    });\n  }\n\n  next();\n};\n/**\n * Stream `path` to the response.\n *\n * @param {String} path\n * @param {Object} options\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.stream = function stream(path, options) {\n  // TODO: this is all lame, refactor meeee\n  var finished = false;\n  var self = this;\n  var res = this.res; // pipe\n\n  var stream = $Opjp$var$fs.createReadStream(path, options);\n  this.emit('stream', stream);\n  stream.pipe(res); // response finished, done with the fd\n\n  $Opjp$var$onFinished(res, function onfinished() {\n    finished = true;\n    $Opjp$var$destroy(stream);\n  }); // error handling code-smell\n\n  stream.on('error', function onerror(err) {\n    // request already finished\n    if (finished) return; // clean up stream\n\n    finished = true;\n    $Opjp$var$destroy(stream); // error\n\n    self.onStatError(err);\n  }); // end\n\n  stream.on('end', function onend() {\n    self.emit('end');\n  });\n};\n/**\n * Set content-type based on `path`\n * if it hasn't been explicitly set.\n *\n * @param {String} path\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.type = function type(path) {\n  var res = this.res;\n  if (res.getHeader('Content-Type')) return;\n  var type = $Opjp$var$mime.lookup(path);\n\n  if (!type) {\n    $Opjp$var$debug('no content-type');\n    return;\n  }\n\n  var charset = $Opjp$var$mime.charsets.lookup(type);\n  $Opjp$var$debug('content-type %s', type);\n  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));\n};\n/**\n * Set response header fields, most\n * fields may be pre-defined.\n *\n * @param {String} path\n * @param {Object} stat\n * @api private\n */\n\n\n$Opjp$var$SendStream.prototype.setHeader = function setHeader(path, stat) {\n  var res = this.res;\n  this.emit('headers', res, path, stat);\n\n  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {\n    $Opjp$var$debug('accept ranges');\n    res.setHeader('Accept-Ranges', 'bytes');\n  }\n\n  if (this._cacheControl && !res.getHeader('Cache-Control')) {\n    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);\n\n    if (this._immutable) {\n      cacheControl += ', immutable';\n    }\n\n    $Opjp$var$debug('cache-control %s', cacheControl);\n    res.setHeader('Cache-Control', cacheControl);\n  }\n\n  if (this._lastModified && !res.getHeader('Last-Modified')) {\n    var modified = stat.mtime.toUTCString();\n    $Opjp$var$debug('modified %s', modified);\n    res.setHeader('Last-Modified', modified);\n  }\n\n  if (this._etag && !res.getHeader('ETag')) {\n    var val = $Opjp$var$etag(stat);\n    $Opjp$var$debug('etag %s', val);\n    res.setHeader('ETag', val);\n  }\n};\n/**\n * Clear all headers from a response.\n *\n * @param {object} res\n * @private\n */\n\n\nfunction $Opjp$var$clearHeaders(res) {\n  var headers = $Opjp$var$getHeaderNames(res);\n\n  for (var i = 0; i < headers.length; i++) {\n    res.removeHeader(headers[i]);\n  }\n}\n/**\n * Collapse all leading slashes into a single slash\n *\n * @param {string} str\n * @private\n */\n\n\nfunction $Opjp$var$collapseLeadingSlashes(str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] !== '/') {\n      break;\n    }\n  }\n\n  return i > 1 ? '/' + str.substr(i) : str;\n}\n/**\n * Determine if path parts contain a dotfile.\n *\n * @api private\n */\n\n\nfunction $Opjp$var$containsDotFile(parts) {\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n\n    if (part.length > 1 && part[0] === '.') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Create a Content-Range header.\n *\n * @param {string} type\n * @param {number} size\n * @param {array} [range]\n */\n\n\nfunction $Opjp$var$contentRange(type, size, range) {\n  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;\n}\n/**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\n\nfunction $Opjp$var$createHtmlDocument(title, body) {\n  return '<!DOCTYPE html>\\n' + '<html lang=\"en\">\\n' + '<head>\\n' + '<meta charset=\"utf-8\">\\n' + '<title>' + title + '</title>\\n' + '</head>\\n' + '<body>\\n' + '<pre>' + body + '</pre>\\n' + '</body>\\n' + '</html>\\n';\n}\n/**\n * decodeURIComponent.\n *\n * Allows V8 to only deoptimize this fn instead of all\n * of send().\n *\n * @param {String} path\n * @api private\n */\n\n\nfunction $Opjp$var$decode(path) {\n  try {\n    return decodeURIComponent(path);\n  } catch (err) {\n    return -1;\n  }\n}\n/**\n * Get the header names on a respnse.\n *\n * @param {object} res\n * @returns {array[string]}\n * @private\n */\n\n\nfunction $Opjp$var$getHeaderNames(res) {\n  return typeof res.getHeaderNames !== 'function' ? Object.keys(res._headers || {}) : res.getHeaderNames();\n}\n/**\n * Determine if emitter has listeners of a given type.\n *\n * The way to do this check is done three different ways in Node.js >= 0.8\n * so this consolidates them into a minimal set using instance methods.\n *\n * @param {EventEmitter} emitter\n * @param {string} type\n * @returns {boolean}\n * @private\n */\n\n\nfunction $Opjp$var$hasListeners(emitter, type) {\n  var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);\n  return count > 0;\n}\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\n\nfunction $Opjp$var$headersSent(res) {\n  return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;\n}\n/**\n * Normalize the index option into an array.\n *\n * @param {boolean|string|array} val\n * @param {string} name\n * @private\n */\n\n\nfunction $Opjp$var$normalizeList(val, name) {\n  var list = [].concat(val || []);\n\n  for (var i = 0; i < list.length; i++) {\n    if (typeof list[i] !== 'string') {\n      throw new TypeError(name + ' must be array of strings or false');\n    }\n  }\n\n  return list;\n}\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\n\nfunction $Opjp$var$parseHttpDate(date) {\n  var timestamp = date && Date.parse(date);\n  return typeof timestamp === 'number' ? timestamp : NaN;\n}\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\n\nfunction $Opjp$var$parseTokenList(str) {\n  var end = 0;\n  var list = [];\n  var start = 0; // gather tokens\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20:\n        /*   */\n        if (start === end) {\n          start = end = i + 1;\n        }\n\n        break;\n\n      case 0x2c:\n        /* , */\n        list.push(str.substring(start, end));\n        start = end = i + 1;\n        break;\n\n      default:\n        end = i + 1;\n        break;\n    }\n  } // final token\n\n\n  list.push(str.substring(start, end));\n  return list;\n}\n/**\n * Set an object of headers on a response.\n *\n * @param {object} res\n * @param {object} headers\n * @private\n */\n\n\nfunction $Opjp$var$setHeaders(res, headers) {\n  var keys = Object.keys(headers);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    res.setHeader(key, headers[key]);\n  }\n}"},"sourceMaps":null,"error":null,"hash":"ddfe013c615815f5c6638d9f75a0a87e","cacheData":{"env":{},"imports":{"$require$http-errors":["http-errors","*"],"$require$debug":["debug","*"],"$require$depd":["depd","*"],"$require$destroy":["destroy","*"],"$require$encodeurl":["encodeurl","*"],"$require$escape-html":["escape-html","*"],"$require$etag":["etag","*"],"$require$fresh":["fresh","*"],"$require$fs":["fs","*"],"$require$mime":["mime","*"],"$require$ms":["ms","*"],"$require$on-finished":["on-finished","*"],"$require$range-parser":["range-parser","*"],"$require$path":["path","*"],"$require$statuses":["statuses","*"],"$require$stream":["stream","*"],"$require$util":["util","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}