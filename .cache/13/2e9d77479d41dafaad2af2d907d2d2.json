{"id":"OFye","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"bn.js","loc":{"line":4,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"minimalistic-assert","loc":{"line":5,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\minimalistic-assert\\index.js"},{"name":"minimalistic-crypto-utils","loc":{"line":6,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\minimalistic-crypto-utils\\lib\\utils.js"}],"generated":{"js":"var $OFye$exports = {};\nvar $OFye$var$utils = $OFye$exports;\nvar $OFye$var$BN = $parcel$require(\"OFye\", \"bn.js\");\nvar $OFye$var$minAssert = $parcel$require(\"OFye\", \"minimalistic-assert\");\nvar $OFye$var$minUtils = $parcel$require(\"OFye\", \"minimalistic-crypto-utils\");\n$OFye$var$utils.assert = $OFye$var$minAssert;\n$OFye$var$utils.toArray = $OFye$var$minUtils.toArray;\n$OFye$var$utils.zero2 = $OFye$var$minUtils.zero2;\n$OFye$var$utils.toHex = $OFye$var$minUtils.toHex;\n$OFye$var$utils.encode = $OFye$var$minUtils.encode; // Represent num in a w-NAF form\n\nfunction $OFye$var$getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n  var ws = 1 << w + 1;\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\n\n$OFye$var$utils.getNAF = $OFye$var$getNAF; // Represent k1, k2 in a Joint Sparse Form\n\nfunction $OFye$var$getJSF(k1, k2) {\n  var jsf = [[], []];\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = k1.andln(3) + d1 & 3;\n    var m24 = k2.andln(3) + d2 & 3;\n    if (m14 === 3) m14 = -1;\n    if (m24 === 3) m24 = -1;\n    var u1;\n\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      var m8 = k1.andln(7) + d1 & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;\n    }\n\n    jsf[0].push(u1);\n    var u2;\n\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      var m8 = k2.andln(7) + d2 & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;\n    }\n\n    jsf[1].push(u2); // Second phase\n\n    if (2 * d1 === u1 + 1) d1 = 1 - d1;\n    if (2 * d2 === u2 + 1) d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\n\n$OFye$var$utils.getJSF = $OFye$var$getJSF;\n\nfunction $OFye$var$cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] : this[key] = computer.call(this);\n  };\n}\n\n$OFye$var$utils.cachedProperty = $OFye$var$cachedProperty;\n\nfunction $OFye$var$parseBytes(bytes) {\n  return typeof bytes === 'string' ? $OFye$var$utils.toArray(bytes, 'hex') : bytes;\n}\n\n$OFye$var$utils.parseBytes = $OFye$var$parseBytes;\n\nfunction $OFye$var$intFromLE(bytes) {\n  return new $OFye$var$BN(bytes, 'hex', 'le');\n}\n\n$OFye$var$utils.intFromLE = $OFye$var$intFromLE;"},"sourceMaps":null,"error":null,"hash":"d9f515d01e7f4e430e74f4eb320fd427","cacheData":{"env":{},"imports":{"$require$bn.js":["bn.js","*"],"$require$minimalistic-assert":["minimalistic-assert","*"],"$require$minimalistic-crypto-utils":["minimalistic-crypto-utils","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}