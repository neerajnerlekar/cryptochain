{"id":"cZ91","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\package.json","includedInParent":true,"mtime":1598465925074},{"name":"buffer","loc":{"line":8,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"},{"name":"stream","loc":{"line":4,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-browserify\\index.js"},{"name":"./binding","loc":{"line":5,"column":22},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js"},{"name":"util","loc":{"line":6,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\util\\util.js"},{"name":"assert","loc":{"line":7,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\assert.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"\nvar $cZ91$exports = {};\nvar $cZ91$var$process = $parcel$require(\"cZ91\", \"process\");\nvar $cZ91$var$Buffer = $parcel$require(\"cZ91\", \"buffer\").Buffer;\nvar $cZ91$var$Transform = $parcel$require(\"cZ91\", \"stream\").Transform;\nvar $cZ91$var$binding = $parcel$require(\"cZ91\", \"./binding\");\nvar $cZ91$var$util = $parcel$require(\"cZ91\", \"util\");\nvar $cZ91$var$assert = $parcel$require(\"cZ91\", \"assert\").ok;\nvar $cZ91$var$kMaxLength = $parcel$require(\"cZ91\", \"buffer\").kMaxLength;\nvar $cZ91$var$kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + $cZ91$var$kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\n\n$cZ91$var$binding.Z_MIN_WINDOWBITS = 8;\n$cZ91$var$binding.Z_MAX_WINDOWBITS = 15;\n$cZ91$var$binding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\n\n$cZ91$var$binding.Z_MIN_CHUNK = 64;\n$cZ91$var$binding.Z_MAX_CHUNK = Infinity;\n$cZ91$var$binding.Z_DEFAULT_CHUNK = 16 * 1024;\n$cZ91$var$binding.Z_MIN_MEMLEVEL = 1;\n$cZ91$var$binding.Z_MAX_MEMLEVEL = 9;\n$cZ91$var$binding.Z_DEFAULT_MEMLEVEL = 8;\n$cZ91$var$binding.Z_MIN_LEVEL = -1;\n$cZ91$var$binding.Z_MAX_LEVEL = 9;\n$cZ91$var$binding.Z_DEFAULT_LEVEL = $cZ91$var$binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants\n\nvar $cZ91$var$bkeys = Object.keys($cZ91$var$binding);\n\nfor (var $cZ91$var$bk = 0; $cZ91$var$bk < $cZ91$var$bkeys.length; $cZ91$var$bk++) {\n  var $cZ91$var$bkey = $cZ91$var$bkeys[$cZ91$var$bk];\n\n  if ($cZ91$var$bkey.match(/^Z/)) {\n    Object.defineProperty($cZ91$exports, $cZ91$var$bkey, {\n      enumerable: true,\n      value: $cZ91$var$binding[$cZ91$var$bkey],\n      writable: false\n    });\n  }\n} // translation table for return codes.\n\n\nvar $cZ91$var$codes = {\n  Z_OK: $cZ91$var$binding.Z_OK,\n  Z_STREAM_END: $cZ91$var$binding.Z_STREAM_END,\n  Z_NEED_DICT: $cZ91$var$binding.Z_NEED_DICT,\n  Z_ERRNO: $cZ91$var$binding.Z_ERRNO,\n  Z_STREAM_ERROR: $cZ91$var$binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: $cZ91$var$binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: $cZ91$var$binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: $cZ91$var$binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: $cZ91$var$binding.Z_VERSION_ERROR\n};\nvar $cZ91$var$ckeys = Object.keys($cZ91$var$codes);\n\nfor (var $cZ91$var$ck = 0; $cZ91$var$ck < $cZ91$var$ckeys.length; $cZ91$var$ck++) {\n  var $cZ91$var$ckey = $cZ91$var$ckeys[$cZ91$var$ck];\n  $cZ91$var$codes[$cZ91$var$codes[$cZ91$var$ckey]] = $cZ91$var$ckey;\n}\n\nObject.defineProperty($cZ91$exports, 'codes', {\n  enumerable: true,\n  value: Object.freeze($cZ91$var$codes),\n  writable: false\n});\nvar $cZ91$export$Deflate = $cZ91$var$Deflate;\n$cZ91$exports.Deflate = $cZ91$export$Deflate;\nvar $cZ91$export$Inflate = $cZ91$var$Inflate;\n$cZ91$exports.Inflate = $cZ91$export$Inflate;\nvar $cZ91$export$Gzip = $cZ91$var$Gzip;\n$cZ91$exports.Gzip = $cZ91$export$Gzip;\nvar $cZ91$export$Gunzip = $cZ91$var$Gunzip;\n$cZ91$exports.Gunzip = $cZ91$export$Gunzip;\nvar $cZ91$export$DeflateRaw = $cZ91$var$DeflateRaw;\n$cZ91$exports.DeflateRaw = $cZ91$export$DeflateRaw;\nvar $cZ91$export$InflateRaw = $cZ91$var$InflateRaw;\n$cZ91$exports.InflateRaw = $cZ91$export$InflateRaw;\nvar $cZ91$export$Unzip = $cZ91$var$Unzip;\n$cZ91$exports.Unzip = $cZ91$export$Unzip;\n\nvar $cZ91$export$createDeflate = function (o) {\n  return new $cZ91$var$Deflate(o);\n};\n\n$cZ91$exports.createDeflate = $cZ91$export$createDeflate;\n\nvar $cZ91$export$createInflate = function (o) {\n  return new $cZ91$var$Inflate(o);\n};\n\n$cZ91$exports.createInflate = $cZ91$export$createInflate;\n\nvar $cZ91$export$createDeflateRaw = function (o) {\n  return new $cZ91$var$DeflateRaw(o);\n};\n\n$cZ91$exports.createDeflateRaw = $cZ91$export$createDeflateRaw;\n\nvar $cZ91$export$createInflateRaw = function (o) {\n  return new $cZ91$var$InflateRaw(o);\n};\n\n$cZ91$exports.createInflateRaw = $cZ91$export$createInflateRaw;\n\nvar $cZ91$export$createGzip = function (o) {\n  return new $cZ91$var$Gzip(o);\n};\n\n$cZ91$exports.createGzip = $cZ91$export$createGzip;\n\nvar $cZ91$export$createGunzip = function (o) {\n  return new $cZ91$var$Gunzip(o);\n};\n\n$cZ91$exports.createGunzip = $cZ91$export$createGunzip;\n\nvar $cZ91$export$createUnzip = function (o) {\n  return new $cZ91$var$Unzip(o);\n};\n\n$cZ91$exports.createUnzip = $cZ91$export$createUnzip; // Convenience methods.\n// compress/decompress a string or buffer in one step.\n\nvar $cZ91$export$deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$Deflate(opts), buffer, callback);\n};\n\n$cZ91$exports.deflate = $cZ91$export$deflate;\n\nvar $cZ91$export$deflateSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$Deflate(opts), buffer);\n};\n\n$cZ91$exports.deflateSync = $cZ91$export$deflateSync;\n\nvar $cZ91$export$gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$Gzip(opts), buffer, callback);\n};\n\n$cZ91$exports.gzip = $cZ91$export$gzip;\n\nvar $cZ91$export$gzipSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$Gzip(opts), buffer);\n};\n\n$cZ91$exports.gzipSync = $cZ91$export$gzipSync;\n\nvar $cZ91$export$deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$DeflateRaw(opts), buffer, callback);\n};\n\n$cZ91$exports.deflateRaw = $cZ91$export$deflateRaw;\n\nvar $cZ91$export$deflateRawSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$DeflateRaw(opts), buffer);\n};\n\n$cZ91$exports.deflateRawSync = $cZ91$export$deflateRawSync;\n\nvar $cZ91$export$unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$Unzip(opts), buffer, callback);\n};\n\n$cZ91$exports.unzip = $cZ91$export$unzip;\n\nvar $cZ91$export$unzipSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$Unzip(opts), buffer);\n};\n\n$cZ91$exports.unzipSync = $cZ91$export$unzipSync;\n\nvar $cZ91$export$inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$Inflate(opts), buffer, callback);\n};\n\n$cZ91$exports.inflate = $cZ91$export$inflate;\n\nvar $cZ91$export$inflateSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$Inflate(opts), buffer);\n};\n\n$cZ91$exports.inflateSync = $cZ91$export$inflateSync;\n\nvar $cZ91$export$gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$Gunzip(opts), buffer, callback);\n};\n\n$cZ91$exports.gunzip = $cZ91$export$gunzip;\n\nvar $cZ91$export$gunzipSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$Gunzip(opts), buffer);\n};\n\n$cZ91$exports.gunzipSync = $cZ91$export$gunzipSync;\n\nvar $cZ91$export$inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return $cZ91$var$zlibBuffer(new $cZ91$var$InflateRaw(opts), buffer, callback);\n};\n\n$cZ91$exports.inflateRaw = $cZ91$export$inflateRaw;\n\nvar $cZ91$export$inflateRawSync = function (buffer, opts) {\n  return $cZ91$var$zlibBufferSync(new $cZ91$var$InflateRaw(opts), buffer);\n};\n\n$cZ91$exports.inflateRawSync = $cZ91$export$inflateRawSync;\n\nfunction $cZ91$var$zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= $cZ91$var$kMaxLength) {\n      err = new RangeError($cZ91$var$kRangeErrorMessage);\n    } else {\n      buf = $cZ91$var$Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction $cZ91$var$zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = $cZ91$var$Buffer.from(buffer);\n  if (!$cZ91$var$Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n  var flushFlag = engine._finishFlushFlag;\n  return engine._processChunk(buffer, flushFlag);\n} // generic zlib\n// minimal 2-byte header\n\n\nfunction $cZ91$var$Deflate(opts) {\n  if (!(this instanceof $cZ91$var$Deflate)) return new $cZ91$var$Deflate(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.DEFLATE);\n}\n\nfunction $cZ91$var$Inflate(opts) {\n  if (!(this instanceof $cZ91$var$Inflate)) return new $cZ91$var$Inflate(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.INFLATE);\n} // gzip - bigger header, same deflate compression\n\n\nfunction $cZ91$var$Gzip(opts) {\n  if (!(this instanceof $cZ91$var$Gzip)) return new $cZ91$var$Gzip(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.GZIP);\n}\n\nfunction $cZ91$var$Gunzip(opts) {\n  if (!(this instanceof $cZ91$var$Gunzip)) return new $cZ91$var$Gunzip(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.GUNZIP);\n} // raw - no header\n\n\nfunction $cZ91$var$DeflateRaw(opts) {\n  if (!(this instanceof $cZ91$var$DeflateRaw)) return new $cZ91$var$DeflateRaw(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.DEFLATERAW);\n}\n\nfunction $cZ91$var$InflateRaw(opts) {\n  if (!(this instanceof $cZ91$var$InflateRaw)) return new $cZ91$var$InflateRaw(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.INFLATERAW);\n} // auto-detect header.\n\n\nfunction $cZ91$var$Unzip(opts) {\n  if (!(this instanceof $cZ91$var$Unzip)) return new $cZ91$var$Unzip(opts);\n  $cZ91$var$Zlib.call(this, opts, $cZ91$var$binding.UNZIP);\n}\n\nfunction $cZ91$var$isValidFlushFlag(flag) {\n  return flag === $cZ91$var$binding.Z_NO_FLUSH || flag === $cZ91$var$binding.Z_PARTIAL_FLUSH || flag === $cZ91$var$binding.Z_SYNC_FLUSH || flag === $cZ91$var$binding.Z_FULL_FLUSH || flag === $cZ91$var$binding.Z_FINISH || flag === $cZ91$var$binding.Z_BLOCK;\n} // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nfunction $cZ91$var$Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || $cZ91$exports.Z_DEFAULT_CHUNK;\n  $cZ91$var$Transform.call(this, opts);\n\n  if (opts.flush && !$cZ91$var$isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n\n  if (opts.finishFlush && !$cZ91$var$isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || $cZ91$var$binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : $cZ91$var$binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < $cZ91$exports.Z_MIN_CHUNK || opts.chunkSize > $cZ91$exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < $cZ91$exports.Z_MIN_WINDOWBITS || opts.windowBits > $cZ91$exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < $cZ91$exports.Z_MIN_LEVEL || opts.level > $cZ91$exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < $cZ91$exports.Z_MIN_MEMLEVEL || opts.memLevel > $cZ91$exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != $cZ91$exports.Z_FILTERED && opts.strategy != $cZ91$exports.Z_HUFFMAN_ONLY && opts.strategy != $cZ91$exports.Z_RLE && opts.strategy != $cZ91$exports.Z_FIXED && opts.strategy != $cZ91$exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!$cZ91$var$Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new $cZ91$var$binding.Zlib(mode);\n  var self = this;\n  this._hadError = false;\n\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    $cZ91$var$_close(self);\n    self._hadError = true;\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = $cZ91$exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = $cZ91$exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n  var strategy = $cZ91$exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || $cZ91$exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || $cZ91$exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = $cZ91$var$Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n  this.once('end', this.close);\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\n$cZ91$var$util.inherits($cZ91$var$Zlib, $cZ91$var$Transform);\n\n$cZ91$var$Zlib.prototype.params = function (level, strategy, callback) {\n  if (level < $cZ91$exports.Z_MIN_LEVEL || level > $cZ91$exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n\n  if (strategy != $cZ91$exports.Z_FILTERED && strategy != $cZ91$exports.Z_HUFFMAN_ONLY && strategy != $cZ91$exports.Z_RLE && strategy != $cZ91$exports.Z_FIXED && strategy != $cZ91$exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush($cZ91$var$binding.Z_SYNC_FLUSH, function () {\n      $cZ91$var$assert(self._handle, 'zlib binding closed');\n\n      self._handle.params(level, strategy);\n\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    $cZ91$var$process.nextTick(callback);\n  }\n};\n\n$cZ91$var$Zlib.prototype.reset = function () {\n  $cZ91$var$assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n}; // This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\n\n\n$cZ91$var$Zlib.prototype._flush = function (callback) {\n  this._transform($cZ91$var$Buffer.alloc(0), '', callback);\n};\n\n$cZ91$var$Zlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = $cZ91$var$binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) $cZ91$var$process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write($cZ91$var$Buffer.alloc(0), '', callback);\n  }\n};\n\n$cZ91$var$Zlib.prototype.close = function (callback) {\n  $cZ91$var$_close(this, callback);\n  $cZ91$var$process.nextTick($cZ91$var$emitCloseNT, this);\n};\n\nfunction $cZ91$var$_close(engine, callback) {\n  if (callback) $cZ91$var$process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).\n\n  if (!engine._handle) return;\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nfunction $cZ91$var$emitCloseNT(self) {\n  self.emit('close');\n}\n\n$cZ91$var$Zlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n  if (chunk !== null && !$cZ91$var$Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || $cZ91$var$binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\n$cZ91$var$Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n  var self = this;\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n    $cZ91$var$assert(this._handle, 'zlib binding closed');\n\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= $cZ91$var$kMaxLength) {\n      $cZ91$var$_close(this);\n      throw new RangeError($cZ91$var$kRangeErrorMessage);\n    }\n\n    var buf = $cZ91$var$Buffer.concat(buffers, nread);\n    $cZ91$var$_close(this);\n    return buf;\n  }\n\n  $cZ91$var$assert(this._handle, 'zlib binding closed');\n\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n    var have = availOutBefore - availOutAfter;\n    $cZ91$var$assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have; // serve some output to the consumer.\n\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    } // exhausted the output buffer, or used all the input create a new one.\n\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = $cZ91$var$Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n\n      newReq.callback = callback; // this same function\n\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false; // finished with the chunk.\n\n    cb();\n  }\n};\n\n$cZ91$var$util.inherits($cZ91$var$Deflate, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$Inflate, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$Gzip, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$Gunzip, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$DeflateRaw, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$InflateRaw, $cZ91$var$Zlib);\n$cZ91$var$util.inherits($cZ91$var$Unzip, $cZ91$var$Zlib);"},"sourceMaps":null,"error":null,"hash":"9f382a3347f1dc511cc112d7091097c0","cacheData":{"env":{},"imports":{"$require$buffer":["buffer","*"],"$require$stream":["stream","*"],"$require$./binding":["./binding","*"],"$require$util":["util","*"],"$require$assert":["assert","*"],"$require$process":["process","*"]},"exports":{"Deflate":"$cZ91$export$Deflate","Inflate":"$cZ91$export$Inflate","Gzip":"$cZ91$export$Gzip","Gunzip":"$cZ91$export$Gunzip","DeflateRaw":"$cZ91$export$DeflateRaw","InflateRaw":"$cZ91$export$InflateRaw","Unzip":"$cZ91$export$Unzip","createDeflate":"$cZ91$export$createDeflate","createInflate":"$cZ91$export$createInflate","createDeflateRaw":"$cZ91$export$createDeflateRaw","createInflateRaw":"$cZ91$export$createInflateRaw","createGzip":"$cZ91$export$createGzip","createGunzip":"$cZ91$export$createGunzip","createUnzip":"$cZ91$export$createUnzip","deflate":"$cZ91$export$deflate","deflateSync":"$cZ91$export$deflateSync","gzip":"$cZ91$export$gzip","gzipSync":"$cZ91$export$gzipSync","deflateRaw":"$cZ91$export$deflateRaw","deflateRawSync":"$cZ91$export$deflateRawSync","unzip":"$cZ91$export$unzip","unzipSync":"$cZ91$export$unzipSync","inflate":"$cZ91$export$inflate","inflateSync":"$cZ91$export$inflateSync","gunzip":"$cZ91$export$gunzip","gunzipSync":"$cZ91$export$gunzipSync","inflateRaw":"$cZ91$export$inflateRaw","inflateRawSync":"$cZ91$export$inflateRawSync"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}