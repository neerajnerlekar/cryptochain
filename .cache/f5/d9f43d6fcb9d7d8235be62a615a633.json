{"id":"p3DA","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\package.json","includedInParent":true,"mtime":1598465886486},{"name":"safe-buffer","loc":{"line":2,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\verify.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\safe-buffer\\index.js"},{"name":"bn.js","loc":{"line":3,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\verify.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\bn.js\\lib\\bn.js"},{"name":"elliptic","loc":{"line":4,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\verify.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\elliptic\\lib\\elliptic.js"},{"name":"parse-asn1","loc":{"line":5,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\verify.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parse-asn1\\index.js"},{"name":"./curves.json","loc":{"line":6,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\verify.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\curves.json"}],"generated":{"js":"\nvar $p3DA$exports = {};\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar $p3DA$var$Buffer = $parcel$require(\"p3DA\", \"safe-buffer\").Buffer;\nvar $p3DA$var$BN = $parcel$require(\"p3DA\", \"bn.js\");\nvar $p3DA$var$EC = $parcel$require(\"p3DA\", \"elliptic\").ec;\nvar $p3DA$var$parseKeys = $parcel$require(\"p3DA\", \"parse-asn1\");\nvar $p3DA$var$curves = $parcel$require(\"p3DA\", \"./curves.json\");\n\nfunction $p3DA$var$verify(sig, hash, key, signType, tag) {\n  var pub = $p3DA$var$parseKeys(key);\n\n  if (pub.type === 'ec') {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');\n    return $p3DA$var$ecVerify(sig, hash, pub);\n  } else if (pub.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong public key type');\n    return $p3DA$var$dsaVerify(sig, hash, pub);\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');\n  }\n\n  hash = $p3DA$var$Buffer.concat([tag, hash]);\n  var len = pub.modulus.byteLength();\n  var pad = [1];\n  var padNum = 0;\n\n  while (hash.length + pad.length + 2 < len) {\n    pad.push(0xff);\n    padNum++;\n  }\n\n  pad.push(0x00);\n  var i = -1;\n\n  while (++i < hash.length) {\n    pad.push(hash[i]);\n  }\n\n  pad = $p3DA$var$Buffer.from(pad);\n  var red = $p3DA$var$BN.mont(pub.modulus);\n  sig = new $p3DA$var$BN(sig).toRed(red);\n  sig = sig.redPow(new $p3DA$var$BN(pub.publicExponent));\n  sig = $p3DA$var$Buffer.from(sig.fromRed().toArray());\n  var out = padNum < 8 ? 1 : 0;\n  len = Math.min(sig.length, pad.length);\n  if (sig.length !== pad.length) out = 1;\n  i = -1;\n\n  while (++i < len) out |= sig[i] ^ pad[i];\n\n  return out === 0;\n}\n\nfunction $p3DA$var$ecVerify(sig, hash, pub) {\n  var curveId = $p3DA$var$curves[pub.data.algorithm.curve.join('.')];\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));\n  var curve = new $p3DA$var$EC(curveId);\n  var pubkey = pub.data.subjectPrivateKey.data;\n  return curve.verify(hash, sig, pubkey);\n}\n\nfunction $p3DA$var$dsaVerify(sig, hash, pub) {\n  var p = pub.data.p;\n  var q = pub.data.q;\n  var g = pub.data.g;\n  var y = pub.data.pub_key;\n  var unpacked = $p3DA$var$parseKeys.signature.decode(sig, 'der');\n  var s = unpacked.s;\n  var r = unpacked.r;\n  $p3DA$var$checkValue(s, q);\n  $p3DA$var$checkValue(r, q);\n  var montp = $p3DA$var$BN.mont(p);\n  var w = s.invm(q);\n  var v = g.toRed(montp).redPow(new $p3DA$var$BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);\n  return v.cmp(r) === 0;\n}\n\nfunction $p3DA$var$checkValue(b, q) {\n  if (b.cmpn(0) <= 0) throw new Error('invalid sig');\n  if (b.cmp(q) >= q) throw new Error('invalid sig');\n}\n\n$p3DA$exports = $p3DA$var$verify;"},"sourceMaps":null,"error":null,"hash":"e48d61f81ebf692282de539f8794aaf6","cacheData":{"env":{},"imports":{"$require$safe-buffer":["safe-buffer","*"],"$require$bn.js":["bn.js","*"],"$require$elliptic":["elliptic","*"],"$require$parse-asn1":["parse-asn1","*"],"$require$./curves.json":["./curves.json","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}