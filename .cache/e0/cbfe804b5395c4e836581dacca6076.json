{"id":"Wt4W","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\etag\\package.json","includedInParent":true,"mtime":1598465921092},{"name":"crypto","loc":{"line":21,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\etag\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\crypto-browserify\\index.js"},{"name":"fs","loc":{"line":22,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\etag\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parcel-bundler\\src\\builtins\\_empty.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\etag\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $Wt4W$exports = {};\nvar $Wt4W$var$Buffer = $parcel$require(\"Wt4W\", \"buffer\").Buffer;\n\n/**\n * Module exports.\n * @public\n */\n$Wt4W$exports = $Wt4W$var$etag;\n/**\n * Module dependencies.\n * @private\n */\n\nvar $Wt4W$var$crypto = $parcel$require(\"Wt4W\", \"crypto\");\nvar $Wt4W$var$Stats = $parcel$require(\"Wt4W\", \"fs\").Stats;\n/**\n * Module variables.\n * @private\n */\n\nvar $Wt4W$var$toString = Object.prototype.toString;\n/**\n * Generate an entity tag.\n *\n * @param {Buffer|string} entity\n * @return {string}\n * @private\n */\n\nfunction $Wt4W$var$entitytag(entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"';\n  } // compute hash of entity\n\n\n  var hash = $Wt4W$var$crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27); // compute length of entity\n\n  var len = typeof entity === 'string' ? $Wt4W$var$Buffer.byteLength(entity, 'utf8') : entity.length;\n  return '\"' + len.toString(16) + '-' + hash + '\"';\n}\n/**\n * Create a simple ETag.\n *\n * @param {string|Buffer|Stats} entity\n * @param {object} [options]\n * @param {boolean} [options.weak]\n * @return {String}\n * @public\n */\n\n\nfunction $Wt4W$var$etag(entity, options) {\n  if (entity == null) {\n    throw new TypeError('argument entity is required');\n  } // support fs.Stats object\n\n\n  var isStats = $Wt4W$var$isstats(entity);\n  var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats; // validate argument\n\n  if (!isStats && typeof entity !== 'string' && !$Wt4W$var$Buffer.isBuffer(entity)) {\n    throw new TypeError('argument entity must be string, Buffer, or fs.Stats');\n  } // generate entity tag\n\n\n  var tag = isStats ? $Wt4W$var$stattag(entity) : $Wt4W$var$entitytag(entity);\n  return weak ? 'W/' + tag : tag;\n}\n/**\n * Determine if object is a Stats object.\n *\n * @param {object} obj\n * @return {boolean}\n * @api private\n */\n\n\nfunction $Wt4W$var$isstats(obj) {\n  // genuine fs.Stats\n  if (typeof $Wt4W$var$Stats === 'function' && obj instanceof $Wt4W$var$Stats) {\n    return true;\n  } // quack quack\n\n\n  return obj && typeof obj === 'object' && 'ctime' in obj && $Wt4W$var$toString.call(obj.ctime) === '[object Date]' && 'mtime' in obj && $Wt4W$var$toString.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';\n}\n/**\n * Generate a tag for a stat.\n *\n * @param {object} stat\n * @return {string}\n * @private\n */\n\n\nfunction $Wt4W$var$stattag(stat) {\n  var mtime = stat.mtime.getTime().toString(16);\n  var size = stat.size.toString(16);\n  return '\"' + size + '-' + mtime + '\"';\n}"},"sourceMaps":null,"error":null,"hash":"c00a32395f807c380d2f1e3410d5990b","cacheData":{"env":{},"imports":{"$require$crypto":["crypto","*"],"$require$fs":["fs","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}