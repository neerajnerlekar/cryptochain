{"id":"ue1q","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\to-arraybuffer\\package.json","includedInParent":true,"mtime":1598465890344},{"name":"buffer","loc":{"line":1,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\to-arraybuffer\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"\nvar $ue1q$exports = {};\nvar $ue1q$var$Buffer = $parcel$require(\"ue1q\", \"buffer\").Buffer;\n\n$ue1q$exports = function (buf) {\n  // If the buffer is backed by a Uint8Array, a faster version will work\n  if (buf instanceof Uint8Array) {\n    // If the buffer isn't a subarray, return the underlying ArrayBuffer\n    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n      return buf.buffer;\n    } else if (typeof buf.buffer.slice === 'function') {\n      // Otherwise we need to get a proper copy\n      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    }\n  }\n\n  if ($ue1q$var$Buffer.isBuffer(buf)) {\n    // This is the slow version that will work with any Buffer\n    // implementation (even in old browsers)\n    var arrayCopy = new Uint8Array(buf.length);\n    var len = buf.length;\n\n    for (var i = 0; i < len; i++) {\n      arrayCopy[i] = buf[i];\n    }\n\n    return arrayCopy.buffer;\n  } else {\n    throw new Error('Argument must be a Buffer');\n  }\n};"},"sourceMaps":null,"error":null,"hash":"7950b5b9aeb74a98aec909e84283cc66","cacheData":{"env":{},"imports":{"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}