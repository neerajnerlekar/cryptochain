{"id":"wWR1","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\package.json","includedInParent":true,"mtime":1598465889591},{"name":"media-typer","loc":{"line":15,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\media-typer\\index.js"},{"name":"mime-types","loc":{"line":16,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\mime-types\\index.js"}],"generated":{"js":"var $wWR1$exports = {};\n\n/**\n * Module dependencies.\n * @private\n */\nvar $wWR1$var$typer = $parcel$require(\"wWR1\", \"media-typer\");\nvar $wWR1$var$mime = $parcel$require(\"wWR1\", \"mime-types\");\n/**\n * Module exports.\n * @public\n */\n\n$wWR1$exports = $wWR1$var$typeofrequest;\n$wWR1$exports.is = $wWR1$var$typeis;\n$wWR1$exports.hasBody = $wWR1$var$hasbody;\n$wWR1$exports.normalize = $wWR1$var$normalize;\n$wWR1$exports.match = $wWR1$var$mimeMatch;\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction $wWR1$var$typeis(value, types_) {\n  var i;\n  var types = types_; // remove parameters and normalize\n\n  var val = $wWR1$var$tryNormalizeType(value); // no type or invalid\n\n  if (!val) {\n    return false;\n  } // support flattened arguments\n\n\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1);\n\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  } // no types, return the content type\n\n\n  if (!types || !types.length) {\n    return val;\n  }\n\n  var type;\n\n  for (i = 0; i < types.length; i++) {\n    if ($wWR1$var$mimeMatch($wWR1$var$normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;\n    }\n  } // no matches\n\n\n  return false;\n}\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\n\nfunction $wWR1$var$hasbody(req) {\n  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);\n}\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\n\nfunction $wWR1$var$typeofrequest(req, types_) {\n  var types = types_; // no body\n\n  if (!$wWR1$var$hasbody(req)) {\n    return null;\n  } // support flattened arguments\n\n\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1);\n\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  } // request content type\n\n\n  var value = req.headers['content-type'];\n  return $wWR1$var$typeis(value, types);\n}\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\n\nfunction $wWR1$var$normalize(type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false;\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n\n    case 'multipart':\n      return 'multipart/*';\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type;\n  }\n\n  return type.indexOf('/') === -1 ? $wWR1$var$mime.lookup(type) : type;\n}\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\n\nfunction $wWR1$var$mimeMatch(expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false;\n  } // split types\n\n\n  var actualParts = actual.split('/');\n  var expectedParts = expected.split('/'); // invalid format\n\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false;\n  } // validate type\n\n\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false;\n  } // validate suffix wildcard\n\n\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);\n  } // validate subtype\n\n\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\n\nfunction $wWR1$var$normalizeType(value) {\n  // parse the type\n  var type = $wWR1$var$typer.parse(value); // remove the parameters\n\n  type.parameters = undefined; // reformat it\n\n  return $wWR1$var$typer.format(type);\n}\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\n\nfunction $wWR1$var$tryNormalizeType(value) {\n  if (!value) {\n    return null;\n  }\n\n  try {\n    return $wWR1$var$normalizeType(value);\n  } catch (err) {\n    return null;\n  }\n}"},"sourceMaps":null,"error":null,"hash":"988f7211273c7d3cfaa44c865ad4ec7e","cacheData":{"env":{},"imports":{"$require$media-typer":["media-typer","*"],"$require$mime-types":["mime-types","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}