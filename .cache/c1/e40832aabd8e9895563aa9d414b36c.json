{"id":"EJKg","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hmac-drbg\\package.json","includedInParent":true,"mtime":1598465911056},{"name":"hash.js","loc":{"line":3,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hmac-drbg\\lib\\hmac-drbg.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash.js\\lib\\hash.js"},{"name":"minimalistic-crypto-utils","loc":{"line":4,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hmac-drbg\\lib\\hmac-drbg.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\minimalistic-crypto-utils\\lib\\utils.js"},{"name":"minimalistic-assert","loc":{"line":5,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hmac-drbg\\lib\\hmac-drbg.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\minimalistic-assert\\index.js"}],"generated":{"js":"var $EJKg$exports = {};\nvar $EJKg$var$hash = $parcel$require(\"EJKg\", \"hash.js\");\nvar $EJKg$var$utils = $parcel$require(\"EJKg\", \"minimalistic-crypto-utils\");\nvar $EJKg$var$assert = $parcel$require(\"EJKg\", \"minimalistic-assert\");\n\nfunction $EJKg$var$HmacDRBG(options) {\n  if (!(this instanceof $EJKg$var$HmacDRBG)) return new $EJKg$var$HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n  var entropy = $EJKg$var$utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = $EJKg$var$utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = $EJKg$var$utils.toArray(options.pers, options.persEnc || 'hex');\n  $EJKg$var$assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._init(entropy, nonce, pers);\n}\n\n$EJKg$exports = $EJKg$var$HmacDRBG;\n\n$EJKg$var$HmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000; // 2^48\n};\n\n$EJKg$var$HmacDRBG.prototype._hmac = function hmac() {\n  return new $EJKg$var$hash.hmac(this.hash, this.K);\n};\n\n$EJKg$var$HmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac().update(this.V).update([0x00]);\n\n  if (seed) kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed) return;\n  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\n$EJKg$var$HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = $EJKg$var$utils.toArray(entropy, entropyEnc);\n  add = $EJKg$var$utils.toArray(add, addEnc);\n  $EJKg$var$assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n\n  this._reseed = 1;\n};\n\n$EJKg$var$HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding\n\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  } // Optional additional data\n\n\n  if (add) {\n    add = $EJKg$var$utils.toArray(add, addEnc || 'hex');\n\n    this._update(add);\n  }\n\n  var temp = [];\n\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n\n  this._update(add);\n\n  this._reseed++;\n  return $EJKg$var$utils.encode(res, enc);\n};"},"sourceMaps":null,"error":null,"hash":"e54d2fa3426dd6f0cb7b5e0262827c92","cacheData":{"env":{},"imports":{"$require$hash.js":["hash.js","*"],"$require$minimalistic-crypto-utils":["minimalistic-crypto-utils","*"],"$require$minimalistic-assert":["minimalistic-assert","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}