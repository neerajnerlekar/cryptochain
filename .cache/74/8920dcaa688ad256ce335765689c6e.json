{"id":"Ztpa","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\iconv-lite\\package.json","includedInParent":true,"mtime":1598465921227},{"name":"buffer","loc":{"line":2,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\iconv-lite\\encodings\\sbcs-codec.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"\nvar $Ztpa$exports = {};\nvar $Ztpa$var$Buffer = $parcel$require(\"Ztpa\", \"buffer\").Buffer; // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nvar $Ztpa$export$_sbcs = $Ztpa$var$SBCSCodec;\n$Ztpa$exports._sbcs = $Ztpa$export$_sbcs;\n\nfunction $Ztpa$var$SBCSCodec(codecOptions, iconv) {\n  if (!codecOptions) throw new Error(\"SBCS codec is called without the data.\"); // Prepare char buffer for decoding.\n\n  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\";\n\n    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);\n\n    codecOptions.chars = asciiString + codecOptions.chars;\n  }\n\n  this.decodeBuf = new $Ztpa$var$Buffer(codecOptions.chars, 'ucs2'); // Encoding buffer.\n\n  var encodeBuf = new $Ztpa$var$Buffer(65536);\n  encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));\n\n  for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n  this.encodeBuf = encodeBuf;\n}\n\n$Ztpa$var$SBCSCodec.prototype.encoder = $Ztpa$var$SBCSEncoder;\n$Ztpa$var$SBCSCodec.prototype.decoder = $Ztpa$var$SBCSDecoder;\n\nfunction $Ztpa$var$SBCSEncoder(options, codec) {\n  this.encodeBuf = codec.encodeBuf;\n}\n\n$Ztpa$var$SBCSEncoder.prototype.write = function (str) {\n  var buf = new $Ztpa$var$Buffer(str.length);\n\n  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];\n\n  return buf;\n};\n\n$Ztpa$var$SBCSEncoder.prototype.end = function () {};\n\nfunction $Ztpa$var$SBCSDecoder(options, codec) {\n  this.decodeBuf = codec.decodeBuf;\n}\n\n$Ztpa$var$SBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf;\n  var newBuf = new $Ztpa$var$Buffer(buf.length * 2);\n  var idx1 = 0,\n      idx2 = 0;\n\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = decodeBuf[idx1];\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];\n  }\n\n  return newBuf.toString('ucs2');\n};\n\n$Ztpa$var$SBCSDecoder.prototype.end = function () {};"},"sourceMaps":null,"error":null,"hash":"aa6481f16513ec87b8bf18bf421cffe1","cacheData":{"env":{},"imports":{"$require$buffer":["buffer","*"]},"exports":{"_sbcs":"$Ztpa$export$_sbcs"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}