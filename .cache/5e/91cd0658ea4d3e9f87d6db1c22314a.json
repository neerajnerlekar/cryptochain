{"id":"zVeg","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\on-finished\\package.json","includedInParent":true,"mtime":1598465907630},{"name":"ee-first","loc":{"line":23,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\on-finished\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\ee-first\\index.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\on-finished\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"var $zVeg$exports = {};\nvar $zVeg$var$process = $parcel$require(\"zVeg\", \"process\");\n\n/**\n * Module exports.\n * @public\n */\n$zVeg$exports = $zVeg$var$onFinished;\n$zVeg$exports.isFinished = $zVeg$var$isFinished;\n/**\n * Module dependencies.\n * @private\n */\n\nvar $zVeg$var$first = $parcel$require(\"zVeg\", \"ee-first\");\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\n\nvar $zVeg$var$defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  $zVeg$var$process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction $zVeg$var$onFinished(msg, listener) {\n  if ($zVeg$var$isFinished(msg) !== false) {\n    $zVeg$var$defer(listener, null, msg);\n    return msg;\n  } // attach the listener to the message\n\n\n  $zVeg$var$attachListener(msg, listener);\n  return msg;\n}\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\n\nfunction $zVeg$var$isFinished(msg) {\n  var socket = msg.socket;\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  } // don't know\n\n\n  return undefined;\n}\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\n\nfunction $zVeg$var$attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  } // finished on first message event\n\n\n  eeMsg = eeSocket = $zVeg$var$first([[msg, 'end', 'finish']], onFinish);\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return; // finished on first socket event\n\n    eeSocket = $zVeg$var$first([[socket, 'error', 'close']], onFinish);\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  } // wait for socket to be assigned\n\n\n  msg.on('socket', onSocket);\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    $zVeg$var$patchAssignSocket(msg, onSocket);\n  }\n}\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\n\nfunction $zVeg$var$attachListener(msg, listener) {\n  var attached = msg.__onFinished; // create a private single listener with queue\n\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = $zVeg$var$createListener(msg);\n    $zVeg$var$attachFinishedListener(msg, attached);\n  }\n\n  attached.queue.push(listener);\n}\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\n\nfunction $zVeg$var$createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n\n  listener.queue = [];\n  return listener;\n}\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\n\nfunction $zVeg$var$patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return; // res.on('socket', callback) is broken in 0.8\n\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}"},"sourceMaps":null,"error":null,"hash":"4f354a6dbb274e623efdd49baa49181a","cacheData":{"env":{},"imports":{"$require$ee-first":["ee-first","*"],"$require$process":["process","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}