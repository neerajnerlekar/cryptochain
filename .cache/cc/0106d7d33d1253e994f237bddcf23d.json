{"id":"D01G","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\array-flatten\\package.json","includedInParent":true,"mtime":1598465926466}],"generated":{"js":"var $D01G$exports = {};\n\n/**\n * Expose `arrayFlatten`.\n */\n$D01G$exports = $D01G$var$arrayFlatten;\n/**\n * Recursive flatten function with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {Number} depth\n * @return {Array}\n */\n\nfunction $D01G$var$flattenWithDepth(array, result, depth) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n\n    if (depth > 0 && Array.isArray(value)) {\n      $D01G$var$flattenWithDepth(value, result, depth - 1);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n/**\n * Recursive flatten function. Omitting depth is slightly faster.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\n\n\nfunction $D01G$var$flattenForever(array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      $D01G$var$flattenForever(value, result);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n/**\n * Flatten an array, with the ability to define a depth.\n *\n * @param  {Array}  array\n * @param  {Number} depth\n * @return {Array}\n */\n\n\nfunction $D01G$var$arrayFlatten(array, depth) {\n  if (depth == null) {\n    return $D01G$var$flattenForever(array, []);\n  }\n\n  return $D01G$var$flattenWithDepth(array, [], depth);\n}"},"sourceMaps":null,"error":null,"hash":"051b564ca728e56a2c79b45afeb3e273","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}