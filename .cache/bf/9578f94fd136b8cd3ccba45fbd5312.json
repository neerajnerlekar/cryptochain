{"id":"reUD","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\package.json","includedInParent":true,"mtime":1598465880655},{"name":"./capability","loc":{"line":1,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\capability.js"},{"name":"inherits","loc":{"line":2,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"},{"name":"readable-stream","loc":{"line":3,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\readable-browser.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $reUD$var$Buffer = $parcel$require(\"reUD\", \"buffer\").Buffer;\nvar $reUD$var$process = $parcel$require(\"reUD\", \"process\");\nvar $reUD$export$readyStates,\n    $reUD$export$IncomingMessage,\n    $reUD$exports = {};\nvar $reUD$var$capability = $parcel$require(\"reUD\", \"./capability\");\nvar $reUD$var$inherits = $parcel$require(\"reUD\", \"inherits\");\nvar $reUD$var$stream = $parcel$require(\"reUD\", \"readable-stream\");\nvar $reUD$var$rStates = ($reUD$export$readyStates = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n}, $reUD$exports.readyStates = $reUD$export$readyStates);\nvar $reUD$var$IncomingMessage = ($reUD$export$IncomingMessage = function (xhr, response, mode, fetchTimer) {\n  var self = this;\n  $reUD$var$stream.Readable.call(self);\n  self._mode = mode;\n  self.headers = {};\n  self.rawHeaders = [];\n  self.trailers = {};\n  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n  self.on('end', function () {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    $reUD$var$process.nextTick(function () {\n      self.emit('close');\n    });\n  });\n\n  if (mode === 'fetch') {\n    self._fetchResponse = response;\n    self.url = response.url;\n    self.statusCode = response.status;\n    self.statusMessage = response.statusText;\n    response.headers.forEach(function (header, key) {\n      self.headers[key.toLowerCase()] = header;\n      self.rawHeaders.push(key, header);\n    });\n\n    if ($reUD$var$capability.writableStream) {\n      var writable = new WritableStream({\n        write: function (chunk) {\n          return new Promise(function (resolve, reject) {\n            if (self._destroyed) {\n              reject();\n            } else if (self.push(new $reUD$var$Buffer(chunk))) {\n              resolve();\n            } else {\n              self._resumeFetch = resolve;\n            }\n          });\n        },\n        close: function () {\n          $parcel$global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.push(null);\n        },\n        abort: function (err) {\n          if (!self._destroyed) self.emit('error', err);\n        }\n      });\n\n      try {\n        response.body.pipeTo(writable).catch(function (err) {\n          $parcel$global.clearTimeout(fetchTimer);\n          if (!self._destroyed) self.emit('error', err);\n        });\n        return;\n      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n    } // fallback for when writableStream or pipeTo aren't available\n\n\n    var reader = response.body.getReader();\n\n    function read() {\n      reader.read().then(function (result) {\n        if (self._destroyed) return;\n\n        if (result.done) {\n          $parcel$global.clearTimeout(fetchTimer);\n          self.push(null);\n          return;\n        }\n\n        self.push(new $reUD$var$Buffer(result.value));\n        read();\n      }).catch(function (err) {\n        $parcel$global.clearTimeout(fetchTimer);\n        if (!self._destroyed) self.emit('error', err);\n      });\n    }\n\n    read();\n  } else {\n    self._xhr = xhr;\n    self._pos = 0;\n    self.url = xhr.responseURL;\n    self.statusCode = xhr.status;\n    self.statusMessage = xhr.statusText;\n    var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n    headers.forEach(function (header) {\n      var matches = header.match(/^([^:]+):\\s*(.*)/);\n\n      if (matches) {\n        var key = matches[1].toLowerCase();\n\n        if (key === 'set-cookie') {\n          if (self.headers[key] === undefined) {\n            self.headers[key] = [];\n          }\n\n          self.headers[key].push(matches[2]);\n        } else if (self.headers[key] !== undefined) {\n          self.headers[key] += ', ' + matches[2];\n        } else {\n          self.headers[key] = matches[2];\n        }\n\n        self.rawHeaders.push(matches[1], matches[2]);\n      }\n    });\n    self._charset = 'x-user-defined';\n\n    if (!$reUD$var$capability.overrideMimeType) {\n      var mimeType = self.rawHeaders['mime-type'];\n\n      if (mimeType) {\n        var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n\n        if (charsetMatch) {\n          self._charset = charsetMatch[1].toLowerCase();\n        }\n      }\n\n      if (!self._charset) self._charset = 'utf-8'; // best guess\n    }\n  }\n}, $reUD$exports.IncomingMessage = $reUD$export$IncomingMessage);\n$reUD$var$inherits($reUD$var$IncomingMessage, $reUD$var$stream.Readable);\n\n$reUD$var$IncomingMessage.prototype._read = function () {\n  var self = this;\n  var resolve = self._resumeFetch;\n\n  if (resolve) {\n    self._resumeFetch = null;\n    resolve();\n  }\n};\n\n$reUD$var$IncomingMessage.prototype._onXHRProgress = function () {\n  var self = this;\n  var xhr = self._xhr;\n  var response = null;\n\n  switch (self._mode) {\n    case 'text:vbarray':\n      // For IE9\n      if (xhr.readyState !== $reUD$var$rStates.DONE) break;\n\n      try {\n        // This fails in IE8\n        response = new $parcel$global.VBArray(xhr.responseBody).toArray();\n      } catch (e) {}\n\n      if (response !== null) {\n        self.push(new $reUD$var$Buffer(response));\n        break;\n      }\n\n    // Falls through in IE8\t\n\n    case 'text':\n      try {\n        // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n        response = xhr.responseText;\n      } catch (e) {\n        self._mode = 'text:vbarray';\n        break;\n      }\n\n      if (response.length > self._pos) {\n        var newData = response.substr(self._pos);\n\n        if (self._charset === 'x-user-defined') {\n          var buffer = new $reUD$var$Buffer(newData.length);\n\n          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;\n\n          self.push(buffer);\n        } else {\n          self.push(newData, self._charset);\n        }\n\n        self._pos = response.length;\n      }\n\n      break;\n\n    case 'arraybuffer':\n      if (xhr.readyState !== $reUD$var$rStates.DONE || !xhr.response) break;\n      response = xhr.response;\n      self.push(new $reUD$var$Buffer(new Uint8Array(response)));\n      break;\n\n    case 'moz-chunked-arraybuffer':\n      // take whole\n      response = xhr.response;\n      if (xhr.readyState !== $reUD$var$rStates.LOADING || !response) break;\n      self.push(new $reUD$var$Buffer(new Uint8Array(response)));\n      break;\n\n    case 'ms-stream':\n      response = xhr.response;\n      if (xhr.readyState !== $reUD$var$rStates.LOADING) break;\n      var reader = new $parcel$global.MSStreamReader();\n\n      reader.onprogress = function () {\n        if (reader.result.byteLength > self._pos) {\n          self.push(new $reUD$var$Buffer(new Uint8Array(reader.result.slice(self._pos))));\n          self._pos = reader.result.byteLength;\n        }\n      };\n\n      reader.onload = function () {\n        self.push(null);\n      }; // reader.onerror = ??? // TODO: this\n\n\n      reader.readAsArrayBuffer(response);\n      break;\n  } // The ms-stream case handles end separately in reader.onload()\n\n\n  if (self._xhr.readyState === $reUD$var$rStates.DONE && self._mode !== 'ms-stream') {\n    self.push(null);\n  }\n};"},"sourceMaps":null,"error":null,"hash":"6b1fe4d2d91fa525b5d8b43dd198b12b","cacheData":{"env":{},"imports":{"$require$./capability":["./capability","*"],"$require$inherits":["inherits","*"],"$require$readable-stream":["readable-stream","*"],"$require$process":["process","*"],"$require$buffer":["buffer","*"]},"exports":{"readyStates":"$reUD$export$readyStates","IncomingMessage":"$reUD$export$IncomingMessage"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}