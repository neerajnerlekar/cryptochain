{"id":"TSmT","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\package.json","includedInParent":true,"mtime":1598465886486},{"name":"safe-buffer","loc":{"line":2,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\safe-buffer\\index.js"},{"name":"create-hmac","loc":{"line":3,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-hmac\\browser.js"},{"name":"browserify-rsa","loc":{"line":4,"column":18},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-rsa\\index.js"},{"name":"elliptic","loc":{"line":5,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\elliptic\\lib\\elliptic.js"},{"name":"bn.js","loc":{"line":6,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\bn.js\\lib\\bn.js"},{"name":"parse-asn1","loc":{"line":7,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parse-asn1\\index.js"},{"name":"./curves.json","loc":{"line":8,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\sign.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\browser\\curves.json"}],"generated":{"js":"\nvar $TSmT$exports = {};\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar $TSmT$var$Buffer = $parcel$require(\"TSmT\", \"safe-buffer\").Buffer;\nvar $TSmT$var$createHmac = $parcel$require(\"TSmT\", \"create-hmac\");\nvar $TSmT$var$crt = $parcel$require(\"TSmT\", \"browserify-rsa\");\nvar $TSmT$var$EC = $parcel$require(\"TSmT\", \"elliptic\").ec;\nvar $TSmT$var$BN = $parcel$require(\"TSmT\", \"bn.js\");\nvar $TSmT$var$parseKeys = $parcel$require(\"TSmT\", \"parse-asn1\");\nvar $TSmT$var$curves = $parcel$require(\"TSmT\", \"./curves.json\");\n\nfunction $TSmT$var$sign(hash, key, hashType, signType, tag) {\n  var priv = $TSmT$var$parseKeys(key);\n\n  if (priv.curve) {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');\n    return $TSmT$var$ecSign(hash, priv);\n  } else if (priv.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong private key type');\n    return $TSmT$var$dsaSign(hash, priv, hashType);\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');\n  }\n\n  hash = $TSmT$var$Buffer.concat([tag, hash]);\n  var len = priv.modulus.byteLength();\n  var pad = [0, 1];\n\n  while (hash.length + pad.length + 1 < len) pad.push(0xff);\n\n  pad.push(0x00);\n  var i = -1;\n\n  while (++i < hash.length) pad.push(hash[i]);\n\n  var out = $TSmT$var$crt(pad, priv);\n  return out;\n}\n\nfunction $TSmT$var$ecSign(hash, priv) {\n  var curveId = $TSmT$var$curves[priv.curve.join('.')];\n  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'));\n  var curve = new $TSmT$var$EC(curveId);\n  var key = curve.keyFromPrivate(priv.privateKey);\n  var out = key.sign(hash);\n  return $TSmT$var$Buffer.from(out.toDER());\n}\n\nfunction $TSmT$var$dsaSign(hash, priv, algo) {\n  var x = priv.params.priv_key;\n  var p = priv.params.p;\n  var q = priv.params.q;\n  var g = priv.params.g;\n  var r = new $TSmT$var$BN(0);\n  var k;\n  var H = $TSmT$var$bits2int(hash, q).mod(q);\n  var s = false;\n  var kv = $TSmT$var$getKey(x, q, hash, algo);\n\n  while (s === false) {\n    k = $TSmT$var$makeKey(q, kv, algo);\n    r = $TSmT$var$makeR(g, k, p, q);\n    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);\n\n    if (s.cmpn(0) === 0) {\n      s = false;\n      r = new $TSmT$var$BN(0);\n    }\n  }\n\n  return $TSmT$var$toDER(r, s);\n}\n\nfunction $TSmT$var$toDER(r, s) {\n  r = r.toArray();\n  s = s.toArray(); // Pad values\n\n  if (r[0] & 0x80) r = [0].concat(r);\n  if (s[0] & 0x80) s = [0].concat(s);\n  var total = r.length + s.length + 4;\n  var res = [0x30, total, 0x02, r.length];\n  res = res.concat(r, [0x02, s.length], s);\n  return $TSmT$var$Buffer.from(res);\n}\n\nfunction $TSmT$var$getKey(x, q, hash, algo) {\n  x = $TSmT$var$Buffer.from(x.toArray());\n\n  if (x.length < q.byteLength()) {\n    var zeros = $TSmT$var$Buffer.alloc(q.byteLength() - x.length);\n    x = $TSmT$var$Buffer.concat([zeros, x]);\n  }\n\n  var hlen = hash.length;\n  var hbits = $TSmT$var$bits2octets(hash, q);\n  var v = $TSmT$var$Buffer.alloc(hlen);\n  v.fill(1);\n  var k = $TSmT$var$Buffer.alloc(hlen);\n  k = $TSmT$var$createHmac(algo, k).update(v).update($TSmT$var$Buffer.from([0])).update(x).update(hbits).digest();\n  v = $TSmT$var$createHmac(algo, k).update(v).digest();\n  k = $TSmT$var$createHmac(algo, k).update(v).update($TSmT$var$Buffer.from([1])).update(x).update(hbits).digest();\n  v = $TSmT$var$createHmac(algo, k).update(v).digest();\n  return {\n    k: k,\n    v: v\n  };\n}\n\nfunction $TSmT$var$bits2int(obits, q) {\n  var bits = new $TSmT$var$BN(obits);\n  var shift = (obits.length << 3) - q.bitLength();\n  if (shift > 0) bits.ishrn(shift);\n  return bits;\n}\n\nfunction $TSmT$var$bits2octets(bits, q) {\n  bits = $TSmT$var$bits2int(bits, q);\n  bits = bits.mod(q);\n  var out = $TSmT$var$Buffer.from(bits.toArray());\n\n  if (out.length < q.byteLength()) {\n    var zeros = $TSmT$var$Buffer.alloc(q.byteLength() - out.length);\n    out = $TSmT$var$Buffer.concat([zeros, out]);\n  }\n\n  return out;\n}\n\nfunction $TSmT$var$makeKey(q, kv, algo) {\n  var t;\n  var k;\n\n  do {\n    t = $TSmT$var$Buffer.alloc(0);\n\n    while (t.length * 8 < q.bitLength()) {\n      kv.v = $TSmT$var$createHmac(algo, kv.k).update(kv.v).digest();\n      t = $TSmT$var$Buffer.concat([t, kv.v]);\n    }\n\n    k = $TSmT$var$bits2int(t, q);\n    kv.k = $TSmT$var$createHmac(algo, kv.k).update(kv.v).update($TSmT$var$Buffer.from([0])).digest();\n    kv.v = $TSmT$var$createHmac(algo, kv.k).update(kv.v).digest();\n  } while (k.cmp(q) !== -1);\n\n  return k;\n}\n\nfunction $TSmT$var$makeR(g, k, p, q) {\n  return g.toRed($TSmT$var$BN.mont(p)).redPow(k).fromRed().mod(q);\n}\n\n$TSmT$exports = $TSmT$var$sign;\n$TSmT$exports.getKey = $TSmT$var$getKey;\n$TSmT$exports.makeKey = $TSmT$var$makeKey;"},"sourceMaps":null,"error":null,"hash":"9a1d96f889ef6df7eb77347c32a4b843","cacheData":{"env":{},"imports":{"$require$safe-buffer":["safe-buffer","*"],"$require$create-hmac":["create-hmac","*"],"$require$browserify-rsa":["browserify-rsa","*"],"$require$elliptic":["elliptic","*"],"$require$bn.js":["bn.js","*"],"$require$parse-asn1":["parse-asn1","*"],"$require$./curves.json":["./curves.json","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}