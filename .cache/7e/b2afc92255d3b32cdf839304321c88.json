{"id":"kDh9","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\package.json","includedInParent":true,"mtime":1598465911105},{"name":"minimalistic-assert","loc":{"line":3,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\des.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\minimalistic-assert\\index.js"},{"name":"inherits","loc":{"line":4,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\des.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"},{"name":"./utils","loc":{"line":6,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\des.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\utils.js"},{"name":"./cipher","loc":{"line":7,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\des.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\des.js\\lib\\des\\cipher.js"}],"generated":{"js":"var $kDh9$exports = {};\nvar $kDh9$var$assert = $parcel$require(\"kDh9\", \"minimalistic-assert\");\nvar $kDh9$var$inherits = $parcel$require(\"kDh9\", \"inherits\");\nvar $kDh9$var$utils = $parcel$require(\"kDh9\", \"./utils\");\nvar $kDh9$var$Cipher = $parcel$require(\"kDh9\", \"./cipher\");\n\nfunction $kDh9$var$DESState() {\n  this.tmp = new Array(2);\n  this.keys = null;\n}\n\nfunction $kDh9$var$DES(options) {\n  $kDh9$var$Cipher.call(this, options);\n  var state = new $kDh9$var$DESState();\n  this._desState = state;\n  this.deriveKeys(state, options.key);\n}\n\n$kDh9$var$inherits($kDh9$var$DES, $kDh9$var$Cipher);\n$kDh9$exports = $kDh9$var$DES;\n\n$kDh9$var$DES.create = function create(options) {\n  return new $kDh9$var$DES(options);\n};\n\nvar $kDh9$var$shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];\n\n$kDh9$var$DES.prototype.deriveKeys = function deriveKeys(state, key) {\n  state.keys = new Array(16 * 2);\n  $kDh9$var$assert.equal(key.length, this.blockSize, 'Invalid key length');\n  var kL = $kDh9$var$utils.readUInt32BE(key, 0);\n  var kR = $kDh9$var$utils.readUInt32BE(key, 4);\n  $kDh9$var$utils.pc1(kL, kR, state.tmp, 0);\n  kL = state.tmp[0];\n  kR = state.tmp[1];\n\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var shift = $kDh9$var$shiftTable[i >>> 1];\n    kL = $kDh9$var$utils.r28shl(kL, shift);\n    kR = $kDh9$var$utils.r28shl(kR, shift);\n    $kDh9$var$utils.pc2(kL, kR, state.keys, i);\n  }\n};\n\n$kDh9$var$DES.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._desState;\n  var l = $kDh9$var$utils.readUInt32BE(inp, inOff);\n  var r = $kDh9$var$utils.readUInt32BE(inp, inOff + 4); // Initial Permutation\n\n  $kDh9$var$utils.ip(l, r, state.tmp, 0);\n  l = state.tmp[0];\n  r = state.tmp[1];\n  if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);\n  l = state.tmp[0];\n  r = state.tmp[1];\n  $kDh9$var$utils.writeUInt32BE(out, l, outOff);\n  $kDh9$var$utils.writeUInt32BE(out, r, outOff + 4);\n};\n\n$kDh9$var$DES.prototype._pad = function _pad(buffer, off) {\n  var value = buffer.length - off;\n\n  for (var i = off; i < buffer.length; i++) buffer[i] = value;\n\n  return true;\n};\n\n$kDh9$var$DES.prototype._unpad = function _unpad(buffer) {\n  var pad = buffer[buffer.length - 1];\n\n  for (var i = buffer.length - pad; i < buffer.length; i++) $kDh9$var$assert.equal(buffer[i], pad);\n\n  return buffer.slice(0, buffer.length - pad);\n};\n\n$kDh9$var$DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {\n  var l = lStart;\n  var r = rStart; // Apply f() x16 times\n\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1]; // f(r, k)\n\n    $kDh9$var$utils.expand(r, state.tmp, 0);\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = $kDh9$var$utils.substitute(keyL, keyR);\n    var f = $kDh9$var$utils.permute(s);\n    var t = r;\n    r = (l ^ f) >>> 0;\n    l = t;\n  } // Reverse Initial Permutation\n\n\n  $kDh9$var$utils.rip(r, l, out, off);\n};\n\n$kDh9$var$DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {\n  var l = rStart;\n  var r = lStart; // Apply f() x16 times\n\n  for (var i = state.keys.length - 2; i >= 0; i -= 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1]; // f(r, k)\n\n    $kDh9$var$utils.expand(l, state.tmp, 0);\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = $kDh9$var$utils.substitute(keyL, keyR);\n    var f = $kDh9$var$utils.permute(s);\n    var t = l;\n    l = (r ^ f) >>> 0;\n    r = t;\n  } // Reverse Initial Permutation\n\n\n  $kDh9$var$utils.rip(l, r, out, off);\n};"},"sourceMaps":null,"error":null,"hash":"efe2b9bf8d9c46e826ed55d95d332332","cacheData":{"env":{},"imports":{"$require$minimalistic-assert":["minimalistic-assert","*"],"$require$inherits":["inherits","*"],"$require$./utils":["./utils","*"],"$require$./cipher":["./cipher","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}