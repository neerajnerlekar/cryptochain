{"id":"CRBE","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\package.json","includedInParent":true,"mtime":1598465887062},{"name":"../../../errors","loc":{"line":16,"column":29},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\errors-browser.js"},{"name":"./end-of-stream","loc":{"line":35,"column":39},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js"}],"generated":{"js":"var $CRBE$exports = {};\nvar $CRBE$var$eos;\n\nfunction $CRBE$var$once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar $CRBE$var$_require$codes = $parcel$require(\"CRBE\", \"../../../errors\").codes,\n    $CRBE$var$ERR_MISSING_ARGS = $CRBE$var$_require$codes.ERR_MISSING_ARGS,\n    $CRBE$var$ERR_STREAM_DESTROYED = $CRBE$var$_require$codes.ERR_STREAM_DESTROYED;\n\nfunction $CRBE$var$noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction $CRBE$var$isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction $CRBE$var$destroyer(stream, reading, writing, callback) {\n  callback = $CRBE$var$once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if ($CRBE$var$eos === undefined) $CRBE$var$eos = $parcel$require(\"CRBE\", \"./end-of-stream\");\n  $CRBE$var$eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if ($CRBE$var$isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new $CRBE$var$ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction $CRBE$var$call(fn) {\n  fn();\n}\n\nfunction $CRBE$var$pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction $CRBE$var$popCallback(streams) {\n  if (!streams.length) return $CRBE$var$noop;\n  if (typeof streams[streams.length - 1] !== 'function') return $CRBE$var$noop;\n  return streams.pop();\n}\n\nfunction $CRBE$var$pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = $CRBE$var$popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new $CRBE$var$ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return $CRBE$var$destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach($CRBE$var$call);\n      if (reading) return;\n      destroys.forEach($CRBE$var$call);\n      callback(error);\n    });\n  });\n  return streams.reduce($CRBE$var$pipe);\n}\n\n$CRBE$exports = $CRBE$var$pipeline;"},"sourceMaps":null,"error":null,"hash":"40e393eb5a55be1344eaec9070c49fc7","cacheData":{"env":{},"imports":{"$require$../../../errors":["../../../errors","*"],"$require$./end-of-stream":["./end-of-stream","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}