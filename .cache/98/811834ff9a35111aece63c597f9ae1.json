{"id":"Sxaw","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\package.json","includedInParent":true,"mtime":1598465910791},{"name":"elliptic","loc":{"line":1,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic.js"},{"name":"bn.js","loc":{"line":2,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\browser.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $Sxaw$exports = {};\nvar $Sxaw$var$Buffer = $parcel$require(\"Sxaw\", \"buffer\").Buffer;\nvar $Sxaw$var$elliptic = $parcel$require(\"Sxaw\", \"elliptic\");\nvar $Sxaw$var$BN = $parcel$require(\"Sxaw\", \"bn.js\");\n\n$Sxaw$exports = function createECDH(curve) {\n  return new $Sxaw$var$ECDH(curve);\n};\n\nvar $Sxaw$var$aliases = {\n  secp256k1: {\n    name: 'secp256k1',\n    byteLength: 32\n  },\n  secp224r1: {\n    name: 'p224',\n    byteLength: 28\n  },\n  prime256v1: {\n    name: 'p256',\n    byteLength: 32\n  },\n  prime192v1: {\n    name: 'p192',\n    byteLength: 24\n  },\n  ed25519: {\n    name: 'ed25519',\n    byteLength: 32\n  },\n  secp384r1: {\n    name: 'p384',\n    byteLength: 48\n  },\n  secp521r1: {\n    name: 'p521',\n    byteLength: 66\n  }\n};\n$Sxaw$var$aliases.p224 = $Sxaw$var$aliases.secp224r1;\n$Sxaw$var$aliases.p256 = $Sxaw$var$aliases.secp256r1 = $Sxaw$var$aliases.prime256v1;\n$Sxaw$var$aliases.p192 = $Sxaw$var$aliases.secp192r1 = $Sxaw$var$aliases.prime192v1;\n$Sxaw$var$aliases.p384 = $Sxaw$var$aliases.secp384r1;\n$Sxaw$var$aliases.p521 = $Sxaw$var$aliases.secp521r1;\n\nfunction $Sxaw$var$ECDH(curve) {\n  this.curveType = $Sxaw$var$aliases[curve];\n\n  if (!this.curveType) {\n    this.curveType = {\n      name: curve\n    };\n  }\n\n  this.curve = new $Sxaw$var$elliptic.ec(this.curveType.name); // eslint-disable-line new-cap\n\n  this.keys = void 0;\n}\n\n$Sxaw$var$ECDH.prototype.generateKeys = function (enc, format) {\n  this.keys = this.curve.genKeyPair();\n  return this.getPublicKey(enc, format);\n};\n\n$Sxaw$var$ECDH.prototype.computeSecret = function (other, inenc, enc) {\n  inenc = inenc || 'utf8';\n\n  if (!$Sxaw$var$Buffer.isBuffer(other)) {\n    other = new $Sxaw$var$Buffer(other, inenc);\n  }\n\n  var otherPub = this.curve.keyFromPublic(other).getPublic();\n  var out = otherPub.mul(this.keys.getPrivate()).getX();\n  return $Sxaw$var$formatReturnValue(out, enc, this.curveType.byteLength);\n};\n\n$Sxaw$var$ECDH.prototype.getPublicKey = function (enc, format) {\n  var key = this.keys.getPublic(format === 'compressed', true);\n\n  if (format === 'hybrid') {\n    if (key[key.length - 1] % 2) {\n      key[0] = 7;\n    } else {\n      key[0] = 6;\n    }\n  }\n\n  return $Sxaw$var$formatReturnValue(key, enc);\n};\n\n$Sxaw$var$ECDH.prototype.getPrivateKey = function (enc) {\n  return $Sxaw$var$formatReturnValue(this.keys.getPrivate(), enc);\n};\n\n$Sxaw$var$ECDH.prototype.setPublicKey = function (pub, enc) {\n  enc = enc || 'utf8';\n\n  if (!$Sxaw$var$Buffer.isBuffer(pub)) {\n    pub = new $Sxaw$var$Buffer(pub, enc);\n  }\n\n  this.keys._importPublic(pub);\n\n  return this;\n};\n\n$Sxaw$var$ECDH.prototype.setPrivateKey = function (priv, enc) {\n  enc = enc || 'utf8';\n\n  if (!$Sxaw$var$Buffer.isBuffer(priv)) {\n    priv = new $Sxaw$var$Buffer(priv, enc);\n  }\n\n  var _priv = new $Sxaw$var$BN(priv);\n\n  _priv = _priv.toString(16);\n  this.keys = this.curve.genKeyPair();\n\n  this.keys._importPrivate(_priv);\n\n  return this;\n};\n\nfunction $Sxaw$var$formatReturnValue(bn, enc, len) {\n  if (!Array.isArray(bn)) {\n    bn = bn.toArray();\n  }\n\n  var buf = new $Sxaw$var$Buffer(bn);\n\n  if (len && buf.length < len) {\n    var zeros = new $Sxaw$var$Buffer(len - buf.length);\n    zeros.fill(0);\n    buf = $Sxaw$var$Buffer.concat([zeros, buf]);\n  }\n\n  if (!enc) {\n    return buf;\n  } else {\n    return buf.toString(enc);\n  }\n}"},"sourceMaps":null,"error":null,"hash":"53913345b74a3cb01d806c1d95ae46ee","cacheData":{"env":{},"imports":{"$require$elliptic":["elliptic","*"],"$require$bn.js":["bn.js","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}