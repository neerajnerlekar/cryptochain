{"id":"HBny","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\package.json","includedInParent":true,"mtime":1598465888872},{"name":"bytes","loc":{"line":15,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bytes\\index.js"},{"name":"content-type","loc":{"line":16,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\content-type\\index.js"},{"name":"http-errors","loc":{"line":17,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\http-errors\\index.js"},{"name":"debug","loc":{"line":18,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\debug\\src\\browser.js"},{"name":"depd","loc":{"line":19,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\depd\\lib\\browser\\index.js"},{"name":"../read","loc":{"line":20,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\read.js"},{"name":"type-is","loc":{"line":21,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\index.js"},{"name":"qs","loc":{"line":225,"column":20},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\qs\\lib\\index.js"},{"name":"querystring","loc":{"line":228,"column":20},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\querystring-es3\\index.js"}],"generated":{"js":"var $HBny$exports = {};\n\n/**\n * Module dependencies.\n * @private\n */\nvar $HBny$var$bytes = $parcel$require(\"HBny\", \"bytes\");\nvar $HBny$var$contentType = $parcel$require(\"HBny\", \"content-type\");\nvar $HBny$var$createError = $parcel$require(\"HBny\", \"http-errors\");\nvar $HBny$var$debug = $parcel$require(\"HBny\", \"debug\")('body-parser:urlencoded');\nvar $HBny$var$deprecate = $parcel$require(\"HBny\", \"depd\")('body-parser');\nvar $HBny$var$read = $parcel$require(\"HBny\", \"../read\");\nvar $HBny$var$typeis = $parcel$require(\"HBny\", \"type-is\");\n/**\n * Module exports.\n */\n\n$HBny$exports = $HBny$var$urlencoded;\n/**\n * Cache of parser modules.\n */\n\nvar $HBny$var$parsers = Object.create(null);\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction $HBny$var$urlencoded(options) {\n  var opts = options || {}; // notice because option default will flip in next major\n\n  if (opts.extended === undefined) {\n    $HBny$var$deprecate('undefined extended: provide extended option');\n  }\n\n  var extended = opts.extended !== false;\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? $HBny$var$bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/x-www-form-urlencoded';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate query parser\n\n\n  var queryparse = extended ? $HBny$var$extendedparser(opts) : $HBny$var$simpleparser(opts); // create the appropriate type checking function\n\n  var shouldParse = typeof type !== 'function' ? $HBny$var$typeChecker(type) : type;\n\n  function parse(body) {\n    return body.length ? queryparse(body) : {};\n  }\n\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      $HBny$var$debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!$HBny$var$typeis.hasBody(req)) {\n      $HBny$var$debug('skip empty body');\n      next();\n      return;\n    }\n\n    $HBny$var$debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      $HBny$var$debug('skip parsing');\n      next();\n      return;\n    } // assert charset\n\n\n    var charset = $HBny$var$getCharset(req) || 'utf-8';\n\n    if (charset !== 'utf-8') {\n      $HBny$var$debug('invalid charset');\n      next($HBny$var$createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    } // read\n\n\n    $HBny$var$read(req, res, next, parse, $HBny$var$debug, {\n      debug: $HBny$var$debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\n\nfunction $HBny$var$extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = $HBny$var$parser('qs');\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n\n  return function queryparse(body) {\n    var paramCount = $HBny$var$parameterCount(body, parameterLimit);\n\n    if (paramCount === undefined) {\n      $HBny$var$debug('too many parameters');\n      throw $HBny$var$createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n\n    var arrayLimit = Math.max(100, paramCount);\n    $HBny$var$debug('parse extended urlencoding');\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    });\n  };\n}\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\n\nfunction $HBny$var$getCharset(req) {\n  try {\n    return ($HBny$var$contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\n\nfunction $HBny$var$parameterCount(body, limit) {\n  var count = 0;\n  var index = 0;\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++;\n    index++;\n\n    if (count === limit) {\n      return undefined;\n    }\n  }\n\n  return count;\n}\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\n\nfunction $HBny$var$parser(name) {\n  var mod = $HBny$var$parsers[name];\n\n  if (mod !== undefined) {\n    return mod.parse;\n  } // this uses a switch for static require analysis\n\n\n  switch (name) {\n    case 'qs':\n      mod = $parcel$require(\"HBny\", \"qs\");\n      break;\n\n    case 'querystring':\n      mod = $parcel$require(\"HBny\", \"querystring\");\n      break;\n  } // store to prevent invoking require()\n\n\n  $HBny$var$parsers[name] = mod;\n  return mod.parse;\n}\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\n\nfunction $HBny$var$simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = $HBny$var$parser('querystring');\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n\n  return function queryparse(body) {\n    var paramCount = $HBny$var$parameterCount(body, parameterLimit);\n\n    if (paramCount === undefined) {\n      $HBny$var$debug('too many parameters');\n      throw $HBny$var$createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n\n    $HBny$var$debug('parse urlencoding');\n    return parse(body, undefined, undefined, {\n      maxKeys: parameterLimit\n    });\n  };\n}\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\n\nfunction $HBny$var$typeChecker(type) {\n  return function checkType(req) {\n    return Boolean($HBny$var$typeis(req, type));\n  };\n}"},"sourceMaps":null,"error":null,"hash":"6460729c58f423bad1ac38ad12771394","cacheData":{"env":{},"imports":{"$require$bytes":["bytes","*"],"$require$content-type":["content-type","*"],"$require$http-errors":["http-errors","*"],"$require$debug":["debug","*"],"$require$depd":["depd","*"],"$require$../read":["../read","*"],"$require$type-is":["type-is","*"],"$require$qs":["qs","*"],"$require$querystring":["querystring","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}