{"id":"ofXZ","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\iconv-lite\\package.json","includedInParent":true,"mtime":1598465921227},{"name":"buffer","loc":{"line":2,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\iconv-lite\\encodings\\utf16.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"\nvar $ofXZ$exports = {};\nvar $ofXZ$var$Buffer = $parcel$require(\"ofXZ\", \"buffer\").Buffer; // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js\n// == UTF16-BE codec. ==========================================================\n\nvar $ofXZ$export$utf16be = $ofXZ$var$Utf16BECodec;\n$ofXZ$exports.utf16be = $ofXZ$export$utf16be;\n\nfunction $ofXZ$var$Utf16BECodec() {}\n\n$ofXZ$var$Utf16BECodec.prototype.encoder = $ofXZ$var$Utf16BEEncoder;\n$ofXZ$var$Utf16BECodec.prototype.decoder = $ofXZ$var$Utf16BEDecoder;\n$ofXZ$var$Utf16BECodec.prototype.bomAware = true; // -- Encoding\n\nfunction $ofXZ$var$Utf16BEEncoder() {}\n\n$ofXZ$var$Utf16BEEncoder.prototype.write = function (str) {\n  var buf = new $ofXZ$var$Buffer(str, 'ucs2');\n\n  for (var i = 0; i < buf.length; i += 2) {\n    var tmp = buf[i];\n    buf[i] = buf[i + 1];\n    buf[i + 1] = tmp;\n  }\n\n  return buf;\n};\n\n$ofXZ$var$Utf16BEEncoder.prototype.end = function () {}; // -- Decoding\n\n\nfunction $ofXZ$var$Utf16BEDecoder() {\n  this.overflowByte = -1;\n}\n\n$ofXZ$var$Utf16BEDecoder.prototype.write = function (buf) {\n  if (buf.length == 0) return '';\n  var buf2 = new $ofXZ$var$Buffer(buf.length + 1),\n      i = 0,\n      j = 0;\n\n  if (this.overflowByte !== -1) {\n    buf2[0] = buf[0];\n    buf2[1] = this.overflowByte;\n    i = 1;\n    j = 2;\n  }\n\n  for (; i < buf.length - 1; i += 2, j += 2) {\n    buf2[j] = buf[i + 1];\n    buf2[j + 1] = buf[i];\n  }\n\n  this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;\n  return buf2.slice(0, j).toString('ucs2');\n};\n\n$ofXZ$var$Utf16BEDecoder.prototype.end = function () {}; // == UTF-16 codec =============================================================\n// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.\n// Defaults to UTF-16LE, as it's prevalent and default in Node.\n// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le\n// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});\n// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).\n\n\nvar $ofXZ$export$utf16 = $ofXZ$var$Utf16Codec;\n$ofXZ$exports.utf16 = $ofXZ$export$utf16;\n\nfunction $ofXZ$var$Utf16Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n}\n\n$ofXZ$var$Utf16Codec.prototype.encoder = $ofXZ$var$Utf16Encoder;\n$ofXZ$var$Utf16Codec.prototype.decoder = $ofXZ$var$Utf16Decoder; // -- Encoding (pass-through)\n\nfunction $ofXZ$var$Utf16Encoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder('utf-16le', options);\n}\n\n$ofXZ$var$Utf16Encoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\n$ofXZ$var$Utf16Encoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction $ofXZ$var$Utf16Decoder(options, codec) {\n  this.decoder = null;\n  this.initialBytes = [];\n  this.initialBytesLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\n$ofXZ$var$Utf16Decoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBytes.push(buf);\n    this.initialBytesLen += buf.length;\n    if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var buf = $ofXZ$var$Buffer.concat(this.initialBytes),\n        encoding = $ofXZ$var$detectEncoding(buf, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    this.initialBytes.length = this.initialBytesLen = 0;\n  }\n\n  return this.decoder.write(buf);\n};\n\n$ofXZ$var$Utf16Decoder.prototype.end = function () {\n  if (!this.decoder) {\n    var buf = $ofXZ$var$Buffer.concat(this.initialBytes),\n        encoding = $ofXZ$var$detectEncoding(buf, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var res = this.decoder.write(buf),\n        trail = this.decoder.end();\n    return trail ? res + trail : res;\n  }\n\n  return this.decoder.end();\n};\n\nfunction $ofXZ$var$detectEncoding(buf, defaultEncoding) {\n  var enc = defaultEncoding || 'utf-16le';\n\n  if (buf.length >= 2) {\n    // Check BOM.\n    if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM\n      enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM\n      enc = 'utf-16le';else {\n      // No BOM found. Try to deduce encoding from initial content.\n      // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.\n      // So, we count ASCII as if it was LE or BE, and decide from that.\n      var asciiCharsLE = 0,\n          asciiCharsBE = 0,\n          // Counts of chars in both positions\n      _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.\n\n\n      for (var i = 0; i < _len; i += 2) {\n        if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;\n        if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;\n      }\n\n      if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';\n    }\n  }\n\n  return enc;\n}"},"sourceMaps":null,"error":null,"hash":"42b3b42a0dfe111e3155a0c19caa88f7","cacheData":{"env":{},"imports":{"$require$buffer":["buffer","*"]},"exports":{"utf16be":"$ofXZ$export$utf16be","utf16":"$ofXZ$export$utf16"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}