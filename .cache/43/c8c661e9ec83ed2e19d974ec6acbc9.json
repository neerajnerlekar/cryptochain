{"id":"ndQm","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"bn.js","loc":{"line":3,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curve\\mont.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"inherits","loc":{"line":4,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curve\\mont.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"},{"name":"./base","loc":{"line":5,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curve\\mont.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curve\\base.js"},{"name":"../utils","loc":{"line":7,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curve\\mont.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js"}],"generated":{"js":"var $ndQm$exports = {};\nvar $ndQm$var$BN = $parcel$require(\"ndQm\", \"bn.js\");\nvar $ndQm$var$inherits = $parcel$require(\"ndQm\", \"inherits\");\nvar $ndQm$var$Base = $parcel$require(\"ndQm\", \"./base\");\nvar $ndQm$var$utils = $parcel$require(\"ndQm\", \"../utils\");\n\nfunction $ndQm$var$MontCurve(conf) {\n  $ndQm$var$Base.call(this, 'mont', conf);\n  this.a = new $ndQm$var$BN(conf.a, 16).toRed(this.red);\n  this.b = new $ndQm$var$BN(conf.b, 16).toRed(this.red);\n  this.i4 = new $ndQm$var$BN(4).toRed(this.red).redInvm();\n  this.two = new $ndQm$var$BN(2).toRed(this.red);\n  this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\n\n$ndQm$var$inherits($ndQm$var$MontCurve, $ndQm$var$Base);\n$ndQm$exports = $ndQm$var$MontCurve;\n\n$ndQm$var$MontCurve.prototype.validate = function validate(point) {\n  var x = point.normalize().x;\n  var x2 = x.redSqr();\n  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\n  var y = rhs.redSqrt();\n  return y.redSqr().cmp(rhs) === 0;\n};\n\nfunction $ndQm$var$Point(curve, x, z) {\n  $ndQm$var$Base.BasePoint.call(this, curve, 'projective');\n\n  if (x === null && z === null) {\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n  } else {\n    this.x = new $ndQm$var$BN(x, 16);\n    this.z = new $ndQm$var$BN(z, 16);\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n  }\n}\n\n$ndQm$var$inherits($ndQm$var$Point, $ndQm$var$Base.BasePoint);\n\n$ndQm$var$MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  return this.point($ndQm$var$utils.toArray(bytes, enc), 1);\n};\n\n$ndQm$var$MontCurve.prototype.point = function point(x, z) {\n  return new $ndQm$var$Point(this, x, z);\n};\n\n$ndQm$var$MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return $ndQm$var$Point.fromJSON(this, obj);\n};\n\n$ndQm$var$Point.prototype.precompute = function precompute() {// No-op\n};\n\n$ndQm$var$Point.prototype._encode = function _encode() {\n  return this.getX().toArray('be', this.curve.p.byteLength());\n};\n\n$ndQm$var$Point.fromJSON = function fromJSON(curve, obj) {\n  return new $ndQm$var$Point(curve, obj[0], obj[1] || curve.one);\n};\n\n$ndQm$var$Point.prototype.inspect = function inspect() {\n  if (this.isInfinity()) return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\n$ndQm$var$Point.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\n$ndQm$var$Point.prototype.dbl = function dbl() {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n  // 2M + 2S + 4A\n  // A = X1 + Z1\n  var a = this.x.redAdd(this.z); // AA = A^2\n\n  var aa = a.redSqr(); // B = X1 - Z1\n\n  var b = this.x.redSub(this.z); // BB = B^2\n\n  var bb = b.redSqr(); // C = AA - BB\n\n  var c = aa.redSub(bb); // X3 = AA * BB\n\n  var nx = aa.redMul(bb); // Z3 = C * (BB + A24 * C)\n\n  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n  return this.curve.point(nx, nz);\n};\n\n$ndQm$var$Point.prototype.add = function add() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\n$ndQm$var$Point.prototype.diffAdd = function diffAdd(p, diff) {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n  // 4M + 2S + 6A\n  // A = X2 + Z2\n  var a = this.x.redAdd(this.z); // B = X2 - Z2\n\n  var b = this.x.redSub(this.z); // C = X3 + Z3\n\n  var c = p.x.redAdd(p.z); // D = X3 - Z3\n\n  var d = p.x.redSub(p.z); // DA = D * A\n\n  var da = d.redMul(a); // CB = C * B\n\n  var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2\n\n  var nx = diff.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2\n\n  var nz = diff.x.redMul(da.redISub(cb).redSqr());\n  return this.curve.point(nx, nz);\n};\n\n$ndQm$var$Point.prototype.mul = function mul(k) {\n  var t = k.clone();\n  var a = this; // (N / 2) * Q + Q\n\n  var b = this.curve.point(null, null); // (N / 2) * Q\n\n  var c = this; // Q\n\n  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));\n\n  for (var i = bits.length - 1; i >= 0; i--) {\n    if (bits[i] === 0) {\n      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q\n      a = a.diffAdd(b, c); // N * Q = 2 * ((N / 2) * Q + Q))\n\n      b = b.dbl();\n    } else {\n      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)\n      b = a.diffAdd(b, c); // N * Q + Q = 2 * ((N / 2) * Q + Q)\n\n      a = a.dbl();\n    }\n  }\n\n  return b;\n};\n\n$ndQm$var$Point.prototype.mulAdd = function mulAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\n$ndQm$var$Point.prototype.jumlAdd = function jumlAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\n$ndQm$var$Point.prototype.eq = function eq(other) {\n  return this.getX().cmp(other.getX()) === 0;\n};\n\n$ndQm$var$Point.prototype.normalize = function normalize() {\n  this.x = this.x.redMul(this.z.redInvm());\n  this.z = this.curve.one;\n  return this;\n};\n\n$ndQm$var$Point.prototype.getX = function getX() {\n  // Normalize coordinates\n  this.normalize();\n  return this.x.fromRed();\n};"},"sourceMaps":null,"error":null,"hash":"ad7e66c816bd166e7b3c151f9498834e","cacheData":{"env":{},"imports":{"$require$bn.js":["bn.js","*"],"$require$inherits":["inherits","*"],"$require$./base":["./base","*"],"$require$../utils":["../utils","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}