{"id":"ndDM","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\package.json","includedInParent":true,"mtime":1598465888872},{"name":"bytes","loc":{"line":15,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bytes\\index.js"},{"name":"content-type","loc":{"line":16,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\content-type\\index.js"},{"name":"http-errors","loc":{"line":17,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\http-errors\\index.js"},{"name":"debug","loc":{"line":18,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\debug\\src\\browser.js"},{"name":"../read","loc":{"line":19,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\read.js"},{"name":"type-is","loc":{"line":20,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\index.js"}],"generated":{"js":"var $ndDM$exports = {};\n\n/**\n * Module dependencies.\n * @private\n */\nvar $ndDM$var$bytes = $parcel$require(\"ndDM\", \"bytes\");\nvar $ndDM$var$contentType = $parcel$require(\"ndDM\", \"content-type\");\nvar $ndDM$var$createError = $parcel$require(\"ndDM\", \"http-errors\");\nvar $ndDM$var$debug = $parcel$require(\"ndDM\", \"debug\")('body-parser:json');\nvar $ndDM$var$read = $parcel$require(\"ndDM\", \"../read\");\nvar $ndDM$var$typeis = $parcel$require(\"ndDM\", \"type-is\");\n/**\n * Module exports.\n */\n\n$ndDM$exports = $ndDM$var$json;\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar $ndDM$var$FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/; // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction $ndDM$var$json(options) {\n  var opts = options || {};\n  var limit = typeof opts.limit !== 'number' ? $ndDM$var$bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? $ndDM$var$typeChecker(type) : type;\n\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {};\n    }\n\n    if (strict) {\n      var first = $ndDM$var$firstchar(body);\n\n      if (first !== '{' && first !== '[') {\n        $ndDM$var$debug('strict violation');\n        throw $ndDM$var$createStrictSyntaxError(body, first);\n      }\n    }\n\n    try {\n      $ndDM$var$debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw $ndDM$var$normalizeJsonSyntaxError(e, {\n        stack: e.stack\n      });\n    }\n  }\n\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      $ndDM$var$debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!$ndDM$var$typeis.hasBody(req)) {\n      $ndDM$var$debug('skip empty body');\n      next();\n      return;\n    }\n\n    $ndDM$var$debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      $ndDM$var$debug('skip parsing');\n      next();\n      return;\n    } // assert charset per RFC 7159 sec 8.1\n\n\n    var charset = $ndDM$var$getCharset(req) || 'utf-8';\n\n    if (charset.substr(0, 4) !== 'utf-') {\n      $ndDM$var$debug('invalid charset');\n      next($ndDM$var$createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    } // read\n\n\n    $ndDM$var$read(req, res, next, parse, $ndDM$var$debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\n\nfunction $ndDM$var$createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = str.substring(0, index) + '#';\n\n  try {\n    JSON.parse(partial);\n    /* istanbul ignore next */\n\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return $ndDM$var$normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    });\n  }\n}\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\n\nfunction $ndDM$var$firstchar(str) {\n  return $ndDM$var$FIRST_CHAR_REGEXP.exec(str)[1];\n}\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\n\nfunction $ndDM$var$getCharset(req) {\n  try {\n    return ($ndDM$var$contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\n\nfunction $ndDM$var$normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  }\n\n  var props = Object.keys(obj);\n\n  for (var j = 0; j < props.length; j++) {\n    var prop = props[j];\n    error[prop] = obj[prop];\n  }\n\n  return error;\n}\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\n\nfunction $ndDM$var$typeChecker(type) {\n  return function checkType(req) {\n    return Boolean($ndDM$var$typeis(req, type));\n  };\n}"},"sourceMaps":null,"error":null,"hash":"e30dae1c170b8046e88f7dcd873f5d59","cacheData":{"env":{},"imports":{"$require$bytes":["bytes","*"],"$require$content-type":["content-type","*"],"$require$http-errors":["http-errors","*"],"$require$debug":["debug","*"],"$require$../read":["../read","*"],"$require$type-is":["type-is","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}