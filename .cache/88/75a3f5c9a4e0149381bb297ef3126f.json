{"id":"DNZI","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\package.json","includedInParent":true,"mtime":1598465888872},{"name":"bytes","loc":{"line":13,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\raw.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bytes\\index.js"},{"name":"debug","loc":{"line":14,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\raw.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\debug\\src\\browser.js"},{"name":"../read","loc":{"line":15,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\raw.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\read.js"},{"name":"type-is","loc":{"line":16,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\raw.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\type-is\\index.js"}],"generated":{"js":"var $DNZI$exports = {};\n\n/**\n * Module dependencies.\n */\nvar $DNZI$var$bytes = $parcel$require(\"DNZI\", \"bytes\");\nvar $DNZI$var$debug = $parcel$require(\"DNZI\", \"debug\")('body-parser:raw');\nvar $DNZI$var$read = $parcel$require(\"DNZI\", \"../read\");\nvar $DNZI$var$typeis = $parcel$require(\"DNZI\", \"type-is\");\n/**\n * Module exports.\n */\n\n$DNZI$exports = $DNZI$var$raw;\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction $DNZI$var$raw(options) {\n  var opts = options || {};\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? $DNZI$var$bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/octet-stream';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? $DNZI$var$typeChecker(type) : type;\n\n  function parse(buf) {\n    return buf;\n  }\n\n  return function rawParser(req, res, next) {\n    if (req._body) {\n      $DNZI$var$debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!$DNZI$var$typeis.hasBody(req)) {\n      $DNZI$var$debug('skip empty body');\n      next();\n      return;\n    }\n\n    $DNZI$var$debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      $DNZI$var$debug('skip parsing');\n      next();\n      return;\n    } // read\n\n\n    $DNZI$var$read(req, res, next, parse, $DNZI$var$debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\n\nfunction $DNZI$var$typeChecker(type) {\n  return function checkType(req) {\n    return Boolean($DNZI$var$typeis(req, type));\n  };\n}"},"sourceMaps":null,"error":null,"hash":"e72a3b7655913452f2d7f0faa131bdef","cacheData":{"env":{},"imports":{"$require$bytes":["bytes","*"],"$require$debug":["debug","*"],"$require$../read":["../read","*"],"$require$type-is":["type-is","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}