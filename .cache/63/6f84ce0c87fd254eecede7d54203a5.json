{"id":"sRre","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\package.json","includedInParent":true,"mtime":1598465886486},{"name":"parse-asn1","loc":{"line":1,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parse-asn1\\index.js"},{"name":"randombytes","loc":{"line":2,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\randombytes\\browser.js"},{"name":"create-hash","loc":{"line":3,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-hash\\browser.js"},{"name":"./mgf","loc":{"line":4,"column":18},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\mgf.js"},{"name":"./xor","loc":{"line":5,"column":18},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\xor.js"},{"name":"bn.js","loc":{"line":6,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"./withPublic","loc":{"line":7,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\withPublic.js"},{"name":"browserify-rsa","loc":{"line":8,"column":18},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-rsa\\index.js"},{"name":"safe-buffer","loc":{"line":9,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\public-encrypt\\publicEncrypt.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\safe-buffer\\index.js"}],"generated":{"js":"\nvar $sRre$exports = {};\nvar $sRre$var$parseKeys = $parcel$require(\"sRre\", \"parse-asn1\");\nvar $sRre$var$randomBytes = $parcel$require(\"sRre\", \"randombytes\");\nvar $sRre$var$createHash = $parcel$require(\"sRre\", \"create-hash\");\nvar $sRre$var$mgf = $parcel$require(\"sRre\", \"./mgf\");\nvar $sRre$var$xor = $parcel$require(\"sRre\", \"./xor\");\nvar $sRre$var$BN = $parcel$require(\"sRre\", \"bn.js\");\nvar $sRre$var$withPublic = $parcel$require(\"sRre\", \"./withPublic\");\nvar $sRre$var$crt = $parcel$require(\"sRre\", \"browserify-rsa\");\nvar $sRre$var$Buffer = $parcel$require(\"sRre\", \"safe-buffer\").Buffer;\n\n$sRre$exports = function publicEncrypt(publicKey, msg, reverse) {\n  var padding;\n\n  if (publicKey.padding) {\n    padding = publicKey.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n\n  var key = $sRre$var$parseKeys(publicKey);\n  var paddedMsg;\n\n  if (padding === 4) {\n    paddedMsg = $sRre$var$oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = $sRre$var$pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new $sRre$var$BN(msg);\n\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n\n  if (reverse) {\n    return $sRre$var$crt(paddedMsg, key);\n  } else {\n    return $sRre$var$withPublic(paddedMsg, key);\n  }\n};\n\nfunction $sRre$var$oaep(key, msg) {\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = $sRre$var$createHash('sha1').update($sRre$var$Buffer.alloc(0)).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n\n  var ps = $sRre$var$Buffer.alloc(k - mLen - hLen2 - 2);\n  var dblen = k - hLen - 1;\n  var seed = $sRre$var$randomBytes(hLen);\n  var maskedDb = $sRre$var$xor($sRre$var$Buffer.concat([iHash, ps, $sRre$var$Buffer.alloc(1, 1), msg], dblen), $sRre$var$mgf(seed, dblen));\n  var maskedSeed = $sRre$var$xor(seed, $sRre$var$mgf(maskedDb, hLen));\n  return new $sRre$var$BN($sRre$var$Buffer.concat([$sRre$var$Buffer.alloc(1), maskedSeed, maskedDb], k));\n}\n\nfunction $sRre$var$pkcs1(key, msg, reverse) {\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n\n  var ps;\n\n  if (reverse) {\n    ps = $sRre$var$Buffer.alloc(k - mLen - 3, 0xff);\n  } else {\n    ps = $sRre$var$nonZero(k - mLen - 3);\n  }\n\n  return new $sRre$var$BN($sRre$var$Buffer.concat([$sRre$var$Buffer.from([0, reverse ? 1 : 2]), ps, $sRre$var$Buffer.alloc(1), msg], k));\n}\n\nfunction $sRre$var$nonZero(len) {\n  var out = $sRre$var$Buffer.allocUnsafe(len);\n  var i = 0;\n  var cache = $sRre$var$randomBytes(len * 2);\n  var cur = 0;\n  var num;\n\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = $sRre$var$randomBytes(len * 2);\n      cur = 0;\n    }\n\n    num = cache[cur++];\n\n    if (num) {\n      out[i++] = num;\n    }\n  }\n\n  return out;\n}"},"sourceMaps":null,"error":null,"hash":"4f42f514c84e6afd0b2851d25f22797c","cacheData":{"env":{},"imports":{"$require$parse-asn1":["parse-asn1","*"],"$require$randombytes":["randombytes","*"],"$require$create-hash":["create-hash","*"],"$require$./mgf":["./mgf","*"],"$require$./xor":["./xor","*"],"$require$bn.js":["bn.js","*"],"$require$./withPublic":["./withPublic","*"],"$require$browserify-rsa":["browserify-rsa","*"],"$require$safe-buffer":["safe-buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}