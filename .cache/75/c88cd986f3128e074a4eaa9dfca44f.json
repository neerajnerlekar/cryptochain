{"id":"svk0","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"bn.js","loc":{"line":3,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"hmac-drbg","loc":{"line":4,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hmac-drbg\\lib\\hmac-drbg.js"},{"name":"../utils","loc":{"line":5,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js"},{"name":"../curves","loc":{"line":6,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curves.js"},{"name":"brorand","loc":{"line":7,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\brorand\\index.js"},{"name":"./key","loc":{"line":10,"column":22},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\key.js"},{"name":"./signature","loc":{"line":11,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\signature.js"}],"generated":{"js":"var $svk0$exports = {};\nvar $svk0$var$BN = $parcel$require(\"svk0\", \"bn.js\");\nvar $svk0$var$HmacDRBG = $parcel$require(\"svk0\", \"hmac-drbg\");\nvar $svk0$var$utils = $parcel$require(\"svk0\", \"../utils\");\nvar $svk0$var$curves = $parcel$require(\"svk0\", \"../curves\");\nvar $svk0$var$rand = $parcel$require(\"svk0\", \"brorand\");\nvar $svk0$var$assert = $svk0$var$utils.assert;\nvar $svk0$var$KeyPair = $parcel$require(\"svk0\", \"./key\");\nvar $svk0$var$Signature = $parcel$require(\"svk0\", \"./signature\");\n\nfunction $svk0$var$EC(options) {\n  if (!(this instanceof $svk0$var$EC)) return new $svk0$var$EC(options); // Shortcut `elliptic.ec(curve-name)`\n\n  if (typeof options === 'string') {\n    $svk0$var$assert($svk0$var$curves.hasOwnProperty(options), 'Unknown curve ' + options);\n    options = $svk0$var$curves[options];\n  } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n\n\n  if (options instanceof $svk0$var$curves.PresetCurve) options = {\n    curve: options\n  };\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g; // Point on curve\n\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG\n\n  this.hash = options.hash || options.curve.hash;\n}\n\n$svk0$exports = $svk0$var$EC;\n\n$svk0$var$EC.prototype.keyPair = function keyPair(options) {\n  return new $svk0$var$KeyPair(this, options);\n};\n\n$svk0$var$EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return $svk0$var$KeyPair.fromPrivate(this, priv, enc);\n};\n\n$svk0$var$EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return $svk0$var$KeyPair.fromPublic(this, pub, enc);\n};\n\n$svk0$var$EC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options) options = {}; // Instantiate Hmac_DRBG\n\n  var drbg = new $svk0$var$HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || $svk0$var$rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray()\n  });\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new $svk0$var$BN(2));\n\n  do {\n    var priv = new $svk0$var$BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0) continue;\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  } while (true);\n};\n\n$svk0$var$EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0) msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;\n};\n\n$svk0$var$EC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n\n  if (!options) options = {};\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new $svk0$var$BN(msg, 16)); // Zero-extend key to provide enough entropy\n\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N\n\n  var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG\n\n  var drbg = new $svk0$var$HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8'\n  }); // Number of bytes to generate\n\n  var ns1 = this.n.sub(new $svk0$var$BN(1));\n\n  for (var iter = 0; true; iter++) {\n    var k = options.k ? options.k(iter) : new $svk0$var$BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;\n    var kp = this.g.mul(k);\n    if (kp.isInfinity()) continue;\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0) continue;\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0) continue;\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`\n\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new $svk0$var$Signature({\n      r: r,\n      s: s,\n      recoveryParam: recoveryParam\n    });\n  }\n};\n\n$svk0$var$EC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new $svk0$var$BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new $svk0$var$Signature(signature, 'hex'); // Perform primitive values validation\n\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature\n\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n\n  if (!this.curve._maxwellTrick) {\n    var p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity()) return false;\n    return p.getX().umod(this.n).cmp(r) === 0;\n  } // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n\n  var p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n\n  return p.eqXToP(r);\n};\n\n$svk0$var$EC.prototype.recoverPubKey = function (msg, signature, j, enc) {\n  $svk0$var$assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new $svk0$var$Signature(signature, enc);\n  var n = this.n;\n  var e = new $svk0$var$BN(msg);\n  var r = signature.r;\n  var s = signature.s; // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.\n\n  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n\n  return this.g.mulAdd(s1, r, s2);\n};\n\n$svk0$var$EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {\n  signature = new $svk0$var$Signature(signature, enc);\n  if (signature.recoveryParam !== null) return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q)) return i;\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n};"},"sourceMaps":null,"error":null,"hash":"28da32088878655f0d77ae8b04c322cc","cacheData":{"env":{},"imports":{"$require$bn.js":["bn.js","*"],"$require$hmac-drbg":["hmac-drbg","*"],"$require$../utils":["../utils","*"],"$require$../curves":["../curves","*"],"$require$brorand":["brorand","*"],"$require$./key":["./key","*"],"$require$./signature":["./signature","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}