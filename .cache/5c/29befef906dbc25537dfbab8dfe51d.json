{"id":"XHze","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\package.json","includedInParent":true,"mtime":1598465888872},{"name":"depd","loc":{"line":14,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\depd\\lib\\browser\\index.js"},{"name":"./lib/types/json","loc":{"line":142,"column":23},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\json.js"},{"name":"./lib/types/raw","loc":{"line":145,"column":23},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\raw.js"},{"name":"./lib/types/text","loc":{"line":148,"column":23},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\text.js"},{"name":"./lib/types/urlencoded","loc":{"line":151,"column":23},"shouldWrap":true,"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\body-parser\\lib\\types\\urlencoded.js"}],"generated":{"js":"var $XHze$exports = {};\n\n/**\n * Module dependencies.\n * @private\n */\nvar $XHze$var$deprecate = $parcel$require(\"XHze\", \"depd\")('body-parser');\n/**\n * Cache of loaded parsers.\n * @private\n */\n\nvar $XHze$var$parsers = Object.create(null);\n/**\n * @typedef Parsers\n * @type {function}\n * @property {function} json\n * @property {function} raw\n * @property {function} text\n * @property {function} urlencoded\n */\n\n/**\n * Module exports.\n * @type {Parsers}\n */\n\n$XHze$exports = $XHze$exports = $XHze$var$deprecate.function($XHze$var$bodyParser, 'bodyParser: use individual json/urlencoded middlewares');\n/**\n * JSON parser.\n * @public\n */\n\nObject.defineProperty($XHze$exports, 'json', {\n  configurable: true,\n  enumerable: true,\n  get: $XHze$var$createParserGetter('json')\n});\n/**\n * Raw parser.\n * @public\n */\n\nObject.defineProperty($XHze$exports, 'raw', {\n  configurable: true,\n  enumerable: true,\n  get: $XHze$var$createParserGetter('raw')\n});\n/**\n * Text parser.\n * @public\n */\n\nObject.defineProperty($XHze$exports, 'text', {\n  configurable: true,\n  enumerable: true,\n  get: $XHze$var$createParserGetter('text')\n});\n/**\n * URL-encoded parser.\n * @public\n */\n\nObject.defineProperty($XHze$exports, 'urlencoded', {\n  configurable: true,\n  enumerable: true,\n  get: $XHze$var$createParserGetter('urlencoded')\n});\n/**\n * Create a middleware to parse json and urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @deprecated\n * @public\n */\n\nfunction $XHze$var$bodyParser(options) {\n  var opts = {}; // exclude type option\n\n  if (options) {\n    for (var prop in options) {\n      if (prop !== 'type') {\n        opts[prop] = options[prop];\n      }\n    }\n  }\n\n  var _urlencoded = $XHze$exports.urlencoded(opts);\n\n  var _json = $XHze$exports.json(opts);\n\n  return function bodyParser(req, res, next) {\n    _json(req, res, function (err) {\n      if (err) return next(err);\n\n      _urlencoded(req, res, next);\n    });\n  };\n}\n/**\n * Create a getter for loading a parser.\n * @private\n */\n\n\nfunction $XHze$var$createParserGetter(name) {\n  return function get() {\n    return $XHze$var$loadParser(name);\n  };\n}\n/**\n * Load a parser module.\n * @private\n */\n\n\nfunction $XHze$var$loadParser(parserName) {\n  var parser = $XHze$var$parsers[parserName];\n\n  if (parser !== undefined) {\n    return parser;\n  } // this uses a switch for static require analysis\n\n\n  switch (parserName) {\n    case 'json':\n      parser = $parcel$require(\"XHze\", \"./lib/types/json\");\n      break;\n\n    case 'raw':\n      parser = $parcel$require(\"XHze\", \"./lib/types/raw\");\n      break;\n\n    case 'text':\n      parser = $parcel$require(\"XHze\", \"./lib/types/text\");\n      break;\n\n    case 'urlencoded':\n      parser = $parcel$require(\"XHze\", \"./lib/types/urlencoded\");\n      break;\n  } // store to prevent invoking require()\n\n\n  return $XHze$var$parsers[parserName] = parser;\n}"},"sourceMaps":null,"error":null,"hash":"c72e7dfad6b86141cfd84d8376225f4c","cacheData":{"env":{},"imports":{"$require$depd":["depd","*"],"$require$./lib/types/json":["./lib/types/json","*"],"$require$./lib/types/raw":["./lib/types/raw","*"],"$require$./lib/types/text":["./lib/types/text","*"],"$require$./lib/types/urlencoded":["./lib/types/urlencoded","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}