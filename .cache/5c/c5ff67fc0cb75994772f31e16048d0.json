{"id":"f17R","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\package.json","includedInParent":true,"mtime":1598465886305},{"name":"./_stream_duplex","loc":{"line":68,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\lib\\_stream_duplex.js"},{"name":"core-util-is","loc":{"line":71,"column":33},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\core-util-is\\lib\\util.js"},{"name":"inherits","loc":{"line":72,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"}],"generated":{"js":"var $f17R$exports = {};\n$f17R$exports = $f17R$var$Transform;\nvar $f17R$var$Duplex = $parcel$require(\"f17R\", \"./_stream_duplex\");\n/*<replacement>*/\n\nvar $f17R$var$util = Object.create($parcel$require(\"f17R\", \"core-util-is\"));\n$f17R$var$util.inherits = $parcel$require(\"f17R\", \"inherits\");\n/*</replacement>*/\n\n$f17R$var$util.inherits($f17R$var$Transform, $f17R$var$Duplex);\n\nfunction $f17R$var$afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction $f17R$var$Transform(options) {\n  if (!(this instanceof $f17R$var$Transform)) return new $f17R$var$Transform(options);\n  $f17R$var$Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: $f17R$var$afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', $f17R$var$prefinish);\n}\n\nfunction $f17R$var$prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      $f17R$var$done(_this, er, data);\n    });\n  } else {\n    $f17R$var$done(this, null, null);\n  }\n}\n\n$f17R$var$Transform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return $f17R$var$Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\n$f17R$var$Transform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\n$f17R$var$Transform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\n$f17R$var$Transform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n$f17R$var$Transform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  $f17R$var$Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n\n    _this2.emit('close');\n  });\n};\n\nfunction $f17R$var$done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n  return stream.push(null);\n}"},"sourceMaps":null,"error":null,"hash":"401338500b2bb973fd9850205377b55a","cacheData":{"env":{},"imports":{"$require$./_stream_duplex":["./_stream_duplex","*"],"$require$core-util-is":["core-util-is","*"],"$require$inherits":["inherits","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}