{"id":"Qgtm","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\package.json","includedInParent":true,"mtime":1598465880655},{"name":"./capability","loc":{"line":1,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\capability.js"},{"name":"inherits","loc":{"line":2,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"},{"name":"./response","loc":{"line":3,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\response.js"},{"name":"readable-stream","loc":{"line":4,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\readable-stream\\readable-browser.js"},{"name":"to-arraybuffer","loc":{"line":5,"column":28},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\to-arraybuffer\\index.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\stream-http\\lib\\request.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"var $Qgtm$exports = {};\nvar $Qgtm$var$process = $parcel$require(\"Qgtm\", \"process\");\nvar $Qgtm$var$Buffer = $parcel$require(\"Qgtm\", \"buffer\").Buffer;\nvar $Qgtm$var$capability = $parcel$require(\"Qgtm\", \"./capability\");\nvar $Qgtm$var$inherits = $parcel$require(\"Qgtm\", \"inherits\");\nvar $Qgtm$var$response = $parcel$require(\"Qgtm\", \"./response\");\nvar $Qgtm$var$stream = $parcel$require(\"Qgtm\", \"readable-stream\");\nvar $Qgtm$var$toArrayBuffer = $parcel$require(\"Qgtm\", \"to-arraybuffer\");\nvar $Qgtm$var$IncomingMessage = $Qgtm$var$response.IncomingMessage;\nvar $Qgtm$var$rStates = $Qgtm$var$response.readyStates;\n\nfunction $Qgtm$var$decideMode(preferBinary, useFetch) {\n  if ($Qgtm$var$capability.fetch && useFetch) {\n    return 'fetch';\n  } else if ($Qgtm$var$capability.mozchunkedarraybuffer) {\n    return 'moz-chunked-arraybuffer';\n  } else if ($Qgtm$var$capability.msstream) {\n    return 'ms-stream';\n  } else if ($Qgtm$var$capability.arraybuffer && preferBinary) {\n    return 'arraybuffer';\n  } else if ($Qgtm$var$capability.vbArray && preferBinary) {\n    return 'text:vbarray';\n  } else {\n    return 'text';\n  }\n}\n\nvar $Qgtm$var$ClientRequest = $Qgtm$exports = function (opts) {\n  var self = this;\n  $Qgtm$var$stream.Writable.call(self);\n  self._opts = opts;\n  self._body = [];\n  self._headers = {};\n  if (opts.auth) self.setHeader('Authorization', 'Basic ' + new $Qgtm$var$Buffer(opts.auth).toString('base64'));\n  Object.keys(opts.headers).forEach(function (name) {\n    self.setHeader(name, opts.headers[name]);\n  });\n  var preferBinary;\n  var useFetch = true;\n\n  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !$Qgtm$var$capability.abortController) {\n    // If the use of XHR should be preferred. Not typically needed.\n    useFetch = false;\n    preferBinary = true;\n  } else if (opts.mode === 'prefer-streaming') {\n    // If streaming is a high priority but binary compatibility and\n    // the accuracy of the 'content-type' header aren't\n    preferBinary = false;\n  } else if (opts.mode === 'allow-wrong-content-type') {\n    // If streaming is more important than preserving the 'content-type' header\n    preferBinary = !$Qgtm$var$capability.overrideMimeType;\n  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n    // Use binary if text streaming may corrupt data or the content-type header, or for speed\n    preferBinary = true;\n  } else {\n    throw new Error('Invalid value for opts.mode');\n  }\n\n  self._mode = $Qgtm$var$decideMode(preferBinary, useFetch);\n  self._fetchTimer = null;\n  self.on('finish', function () {\n    self._onFinish();\n  });\n};\n\n$Qgtm$var$inherits($Qgtm$var$ClientRequest, $Qgtm$var$stream.Writable);\n\n$Qgtm$var$ClientRequest.prototype.setHeader = function (name, value) {\n  var self = this;\n  var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe\n  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n  // http-browserify did it, so I will too.\n\n  if ($Qgtm$var$unsafeHeaders.indexOf(lowerName) !== -1) return;\n  self._headers[lowerName] = {\n    name: name,\n    value: value\n  };\n};\n\n$Qgtm$var$ClientRequest.prototype.getHeader = function (name) {\n  var header = this._headers[name.toLowerCase()];\n\n  if (header) return header.value;\n  return null;\n};\n\n$Qgtm$var$ClientRequest.prototype.removeHeader = function (name) {\n  var self = this;\n  delete self._headers[name.toLowerCase()];\n};\n\n$Qgtm$var$ClientRequest.prototype._onFinish = function () {\n  var self = this;\n  if (self._destroyed) return;\n  var opts = self._opts;\n  var headersObj = self._headers;\n  var body = null;\n\n  if (opts.method !== 'GET' && opts.method !== 'HEAD') {\n    if ($Qgtm$var$capability.arraybuffer) {\n      body = $Qgtm$var$toArrayBuffer($Qgtm$var$Buffer.concat(self._body));\n    } else if ($Qgtm$var$capability.blobConstructor) {\n      body = new $parcel$global.Blob(self._body.map(function (buffer) {\n        return $Qgtm$var$toArrayBuffer(buffer);\n      }), {\n        type: (headersObj['content-type'] || {}).value || ''\n      });\n    } else {\n      // get utf8 string\n      body = $Qgtm$var$Buffer.concat(self._body).toString();\n    }\n  } // create flattened list of headers\n\n\n  var headersList = [];\n  Object.keys(headersObj).forEach(function (keyName) {\n    var name = headersObj[keyName].name;\n    var value = headersObj[keyName].value;\n\n    if (Array.isArray(value)) {\n      value.forEach(function (v) {\n        headersList.push([name, v]);\n      });\n    } else {\n      headersList.push([name, value]);\n    }\n  });\n\n  if (self._mode === 'fetch') {\n    var signal = null;\n    var fetchTimer = null;\n\n    if ($Qgtm$var$capability.abortController) {\n      var controller = new AbortController();\n      signal = controller.signal;\n      self._fetchAbortController = controller;\n\n      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n        self._fetchTimer = $parcel$global.setTimeout(function () {\n          self.emit('requestTimeout');\n          if (self._fetchAbortController) self._fetchAbortController.abort();\n        }, opts.requestTimeout);\n      }\n    }\n\n    $parcel$global.fetch(self._opts.url, {\n      method: self._opts.method,\n      headers: headersList,\n      body: body || undefined,\n      mode: 'cors',\n      credentials: opts.withCredentials ? 'include' : 'same-origin',\n      signal: signal\n    }).then(function (response) {\n      self._fetchResponse = response;\n\n      self._connect();\n    }, function (reason) {\n      $parcel$global.clearTimeout(self._fetchTimer);\n      if (!self._destroyed) self.emit('error', reason);\n    });\n  } else {\n    var xhr = self._xhr = new $parcel$global.XMLHttpRequest();\n\n    try {\n      xhr.open(self._opts.method, self._opts.url, true);\n    } catch (err) {\n      $Qgtm$var$process.nextTick(function () {\n        self.emit('error', err);\n      });\n      return;\n    } // Can't set responseType on really old browsers\n\n\n    if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];\n    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;\n    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\n    if ('requestTimeout' in opts) {\n      xhr.timeout = opts.requestTimeout;\n\n      xhr.ontimeout = function () {\n        self.emit('requestTimeout');\n      };\n    }\n\n    headersList.forEach(function (header) {\n      xhr.setRequestHeader(header[0], header[1]);\n    });\n    self._response = null;\n\n    xhr.onreadystatechange = function () {\n      switch (xhr.readyState) {\n        case $Qgtm$var$rStates.LOADING:\n        case $Qgtm$var$rStates.DONE:\n          self._onXHRProgress();\n\n          break;\n      }\n    }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined\n    // in onprogress, not in onreadystatechange with xhr.readyState = 3\n\n\n    if (self._mode === 'moz-chunked-arraybuffer') {\n      xhr.onprogress = function () {\n        self._onXHRProgress();\n      };\n    }\n\n    xhr.onerror = function () {\n      if (self._destroyed) return;\n      self.emit('error', new Error('XHR error'));\n    };\n\n    try {\n      xhr.send(body);\n    } catch (err) {\n      $Qgtm$var$process.nextTick(function () {\n        self.emit('error', err);\n      });\n      return;\n    }\n  }\n};\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\n\n\nfunction $Qgtm$var$statusValid(xhr) {\n  try {\n    var status = xhr.status;\n    return status !== null && status !== 0;\n  } catch (e) {\n    return false;\n  }\n}\n\n$Qgtm$var$ClientRequest.prototype._onXHRProgress = function () {\n  var self = this;\n  if (!$Qgtm$var$statusValid(self._xhr) || self._destroyed) return;\n  if (!self._response) self._connect();\n\n  self._response._onXHRProgress();\n};\n\n$Qgtm$var$ClientRequest.prototype._connect = function () {\n  var self = this;\n  if (self._destroyed) return;\n  self._response = new $Qgtm$var$IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);\n\n  self._response.on('error', function (err) {\n    self.emit('error', err);\n  });\n\n  self.emit('response', self._response);\n};\n\n$Qgtm$var$ClientRequest.prototype._write = function (chunk, encoding, cb) {\n  var self = this;\n\n  self._body.push(chunk);\n\n  cb();\n};\n\n$Qgtm$var$ClientRequest.prototype.abort = $Qgtm$var$ClientRequest.prototype.destroy = function () {\n  var self = this;\n  self._destroyed = true;\n  $parcel$global.clearTimeout(self._fetchTimer);\n  if (self._response) self._response._destroyed = true;\n  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();\n};\n\n$Qgtm$var$ClientRequest.prototype.end = function (data, encoding, cb) {\n  var self = this;\n\n  if (typeof data === 'function') {\n    cb = data;\n    data = undefined;\n  }\n\n  $Qgtm$var$stream.Writable.prototype.end.call(self, data, encoding, cb);\n};\n\n$Qgtm$var$ClientRequest.prototype.flushHeaders = function () {};\n\n$Qgtm$var$ClientRequest.prototype.setTimeout = function () {};\n\n$Qgtm$var$ClientRequest.prototype.setNoDelay = function () {};\n\n$Qgtm$var$ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\n\n\nvar $Qgtm$var$unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];"},"sourceMaps":null,"error":null,"hash":"1890a8f4c21fa4ac0d0ec57ba81cab6e","cacheData":{"env":{},"imports":{"$require$./capability":["./capability","*"],"$require$inherits":["inherits","*"],"$require$./response":["./response","*"],"$require$readable-stream":["readable-stream","*"],"$require$to-arraybuffer":["to-arraybuffer","*"],"$require$buffer":["buffer","*"],"$require$process":["process","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}