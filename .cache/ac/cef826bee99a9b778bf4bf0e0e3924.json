{"id":"lmwp","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"bn.js","loc":{"line":3,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\signature.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"../utils","loc":{"line":5,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\signature.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js"}],"generated":{"js":"var $lmwp$exports = {};\nvar $lmwp$var$BN = $parcel$require(\"lmwp\", \"bn.js\");\nvar $lmwp$var$utils = $parcel$require(\"lmwp\", \"../utils\");\nvar $lmwp$var$assert = $lmwp$var$utils.assert;\n\nfunction $lmwp$var$Signature(options, enc) {\n  if (options instanceof $lmwp$var$Signature) return options;\n  if (this._importDER(options, enc)) return;\n  $lmwp$var$assert(options.r && options.s, 'Signature without r or s');\n  this.r = new $lmwp$var$BN(options.r, 16);\n  this.s = new $lmwp$var$BN(options.s, 16);\n  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;\n}\n\n$lmwp$exports = $lmwp$var$Signature;\n\nfunction $lmwp$var$Position() {\n  this.place = 0;\n}\n\nfunction $lmwp$var$getLength(buf, p) {\n  var initial = buf[p.place++];\n\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n\n  var octetLen = initial & 0xf; // Indefinite length or overflow\n\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  } // Leading zeroes\n\n\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction $lmwp$var$rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n\n  if (i === 0) {\n    return buf;\n  }\n\n  return buf.slice(i);\n}\n\n$lmwp$var$Signature.prototype._importDER = function _importDER(data, enc) {\n  data = $lmwp$var$utils.toArray(data, enc);\n  var p = new $lmwp$var$Position();\n\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n\n  var len = $lmwp$var$getLength(data, p);\n\n  if (len === false) {\n    return false;\n  }\n\n  if (len + p.place !== data.length) {\n    return false;\n  }\n\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n\n  var rlen = $lmwp$var$getLength(data, p);\n\n  if (rlen === false) {\n    return false;\n  }\n\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n\n  var slen = $lmwp$var$getLength(data, p);\n\n  if (slen === false) {\n    return false;\n  }\n\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n\n  var s = data.slice(p.place, slen + p.place);\n\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new $lmwp$var$BN(r);\n  this.s = new $lmwp$var$BN(s);\n  this.recoveryParam = null;\n  return true;\n};\n\nfunction $lmwp$var$constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n\n  while (--octets) {\n    arr.push(len >>> (octets << 3) & 0xff);\n  }\n\n  arr.push(len);\n}\n\n$lmwp$var$Signature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray(); // Pad values\n\n  if (r[0] & 0x80) r = [0].concat(r); // Pad values\n\n  if (s[0] & 0x80) s = [0].concat(s);\n  r = $lmwp$var$rmPadding(r);\n  s = $lmwp$var$rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n\n  var arr = [0x02];\n  $lmwp$var$constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  $lmwp$var$constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [0x30];\n  $lmwp$var$constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return $lmwp$var$utils.encode(res, enc);\n};"},"sourceMaps":null,"error":null,"hash":"be5e6dfe89ea41a1fe6610c944707dd0","cacheData":{"env":{},"imports":{"$require$bn.js":["bn.js","*"],"$require$../utils":["../utils","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}