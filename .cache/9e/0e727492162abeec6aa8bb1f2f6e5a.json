{"id":"ZRX3","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"bn.js","loc":{"line":3,"column":17},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\key.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bn.js\\lib\\bn.js"},{"name":"../utils","loc":{"line":4,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\ec\\key.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js"}],"generated":{"js":"var $ZRX3$exports = {};\nvar $ZRX3$var$BN = $parcel$require(\"ZRX3\", \"bn.js\");\nvar $ZRX3$var$utils = $parcel$require(\"ZRX3\", \"../utils\");\nvar $ZRX3$var$assert = $ZRX3$var$utils.assert;\n\nfunction $ZRX3$var$KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })\n\n  if (options.priv) this._importPrivate(options.priv, options.privEnc);\n  if (options.pub) this._importPublic(options.pub, options.pubEnc);\n}\n\n$ZRX3$exports = $ZRX3$var$KeyPair;\n\n$ZRX3$var$KeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof $ZRX3$var$KeyPair) return pub;\n  return new $ZRX3$var$KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\n$ZRX3$var$KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof $ZRX3$var$KeyPair) return priv;\n  return new $ZRX3$var$KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\n$ZRX3$var$KeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n  if (pub.isInfinity()) return {\n    result: false,\n    reason: 'Invalid public key'\n  };\n  if (!pub.validate()) return {\n    result: false,\n    reason: 'Public key is not a point'\n  };\n  if (!pub.mul(this.ec.curve.n).isInfinity()) return {\n    result: false,\n    reason: 'Public key * N != O'\n  };\n  return {\n    result: true,\n    reason: null\n  };\n};\n\n$ZRX3$var$KeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub) this.pub = this.ec.g.mul(this.priv);\n  if (!enc) return this.pub;\n  return this.pub.encode(enc, compact);\n};\n\n$ZRX3$var$KeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;\n};\n\n$ZRX3$var$KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new $ZRX3$var$BN(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\n$ZRX3$var$KeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      $ZRX3$var$assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {\n      $ZRX3$var$assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n\n  this.pub = this.ec.curve.decodePoint(key, enc);\n}; // ECDH\n\n\n$ZRX3$var$KeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n}; // ECDSA\n\n\n$ZRX3$var$KeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\n$ZRX3$var$KeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\n$ZRX3$var$KeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};"},"sourceMaps":null,"error":null,"hash":"4df15c2b06a2a5bf284484e2ee51fb13","cacheData":{"env":{},"imports":{"$require$bn.js":["bn.js","*"],"$require$../utils":["../utils","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}