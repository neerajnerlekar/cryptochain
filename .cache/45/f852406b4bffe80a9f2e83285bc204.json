{"id":"LPjT","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\forwarded\\package.json","includedInParent":true,"mtime":1598465920214}],"generated":{"js":"var $LPjT$exports = {};\n\n/**\n * Module exports.\n * @public\n */\n$LPjT$exports = $LPjT$var$forwarded;\n/**\n * Get all addresses in the request, using the `X-Forwarded-For` header.\n *\n * @param {object} req\n * @return {array}\n * @public\n */\n\nfunction $LPjT$var$forwarded(req) {\n  if (!req) {\n    throw new TypeError('argument req is required');\n  } // simple header parsing\n\n\n  var proxyAddrs = $LPjT$var$parse(req.headers['x-forwarded-for'] || '');\n  var socketAddr = req.connection.remoteAddress;\n  var addrs = [socketAddr].concat(proxyAddrs); // return all addresses\n\n  return addrs;\n}\n/**\n * Parse the X-Forwarded-For header.\n *\n * @param {string} header\n * @private\n */\n\n\nfunction $LPjT$var$parse(header) {\n  var end = header.length;\n  var list = [];\n  var start = header.length; // gather addresses, backwards\n\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20:\n        /*   */\n        if (start === end) {\n          start = end = i;\n        }\n\n        break;\n\n      case 0x2c:\n        /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end));\n        }\n\n        start = end = i;\n        break;\n\n      default:\n        start = i;\n        break;\n    }\n  } // final address\n\n\n  if (start !== end) {\n    list.push(header.substring(start, end));\n  }\n\n  return list;\n}"},"sourceMaps":null,"error":null,"hash":"c0e5cb9dcc85dd474047e43a9070013b","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}