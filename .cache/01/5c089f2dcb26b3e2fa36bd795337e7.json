{"id":"wDmc","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\package.json","includedInParent":true,"mtime":1598465887072},{"name":"../errors","loc":{"line":66,"column":29},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\errors-browser.js"},{"name":"./_stream_duplex","loc":{"line":72,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\lib\\_stream_duplex.js"},{"name":"inherits","loc":{"line":74,"column":8},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-sign\\node_modules\\readable-stream\\lib\\_stream_transform.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"}],"generated":{"js":"var $wDmc$exports = {};\n$wDmc$exports = $wDmc$var$Transform;\nvar $wDmc$var$_require$codes = $parcel$require(\"wDmc\", \"../errors\").codes,\n    $wDmc$var$ERR_METHOD_NOT_IMPLEMENTED = $wDmc$var$_require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    $wDmc$var$ERR_MULTIPLE_CALLBACK = $wDmc$var$_require$codes.ERR_MULTIPLE_CALLBACK,\n    $wDmc$var$ERR_TRANSFORM_ALREADY_TRANSFORMING = $wDmc$var$_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    $wDmc$var$ERR_TRANSFORM_WITH_LENGTH_0 = $wDmc$var$_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar $wDmc$var$Duplex = $parcel$require(\"wDmc\", \"./_stream_duplex\");\n$parcel$require(\"wDmc\", \"inherits\")($wDmc$var$Transform, $wDmc$var$Duplex);\n\nfunction $wDmc$var$afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new $wDmc$var$ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction $wDmc$var$Transform(options) {\n  if (!(this instanceof $wDmc$var$Transform)) return new $wDmc$var$Transform(options);\n  $wDmc$var$Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: $wDmc$var$afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', $wDmc$var$prefinish);\n}\n\nfunction $wDmc$var$prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      $wDmc$var$done(_this, er, data);\n    });\n  } else {\n    $wDmc$var$done(this, null, null);\n  }\n}\n\n$wDmc$var$Transform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return $wDmc$var$Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\n$wDmc$var$Transform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new $wDmc$var$ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\n$wDmc$var$Transform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\n$wDmc$var$Transform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n$wDmc$var$Transform.prototype._destroy = function (err, cb) {\n  $wDmc$var$Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction $wDmc$var$done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new $wDmc$var$ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new $wDmc$var$ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}"},"sourceMaps":null,"error":null,"hash":"f4f0f57e80a5c268ea0eb233773ffb81","cacheData":{"env":{},"imports":{"$require$../errors":["../errors","*"],"$require$./_stream_duplex":["./_stream_duplex","*"],"$require$inherits":["inherits","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}