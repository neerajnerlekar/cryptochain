{"id":"pDrw","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\package.json","includedInParent":true,"mtime":1598465908268},{"name":"object-assign","loc":{"line":3,"column":27},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\assert.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\object-assign\\index.js"},{"name":"util/","loc":{"line":73,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\assert.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\node_modules\\util\\util.js"}],"generated":{"js":"var $pDrw$exports = {};\nvar $pDrw$var$objectAssign = $parcel$require(\"pDrw\", \"object-assign\"); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nfunction $pDrw$var$compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n\n  if (y < x) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction $pDrw$var$isBuffer(b) {\n  if ($parcel$global.Buffer && typeof $parcel$global.Buffer.isBuffer === 'function') {\n    return $parcel$global.Buffer.isBuffer(b);\n  }\n\n  return !!(b != null && b._isBuffer);\n} // based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvar $pDrw$var$util = $parcel$require(\"pDrw\", \"util/\");\nvar $pDrw$var$hasOwn = Object.prototype.hasOwnProperty;\nvar $pDrw$var$pSlice = Array.prototype.slice;\n\nvar $pDrw$var$functionsHaveNames = function () {\n  return function foo() {}.name === 'foo';\n}();\n\nfunction $pDrw$var$pToString(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction $pDrw$var$isView(arrbuf) {\n  if ($pDrw$var$isBuffer(arrbuf)) {\n    return false;\n  }\n\n  if (typeof $parcel$global.ArrayBuffer !== 'function') {\n    return false;\n  }\n\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n\n  if (!arrbuf) {\n    return false;\n  }\n\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n\n  return false;\n} // 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\n\nvar $pDrw$var$assert = $pDrw$exports = $pDrw$var$ok; // 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar $pDrw$var$regex = /\\s*function\\s+([^\\(\\s]*)\\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\n\nfunction $pDrw$var$getName(func) {\n  if (!$pDrw$var$util.isFunction(func)) {\n    return;\n  }\n\n  if ($pDrw$var$functionsHaveNames) {\n    return func.name;\n  }\n\n  var str = func.toString();\n  var match = str.match($pDrw$var$regex);\n  return match && match[1];\n}\n\n$pDrw$var$assert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = $pDrw$var$getMessage(this);\n    this.generatedMessage = true;\n  }\n\n  var stackStartFunction = options.stackStartFunction || $pDrw$var$fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n\n    if (err.stack) {\n      var out = err.stack; // try to strip useless frames\n\n      var fn_name = $pDrw$var$getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n}; // assert.AssertionError instanceof Error\n\n\n$pDrw$var$util.inherits($pDrw$var$assert.AssertionError, Error);\n\nfunction $pDrw$var$truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction $pDrw$var$inspect(something) {\n  if ($pDrw$var$functionsHaveNames || !$pDrw$var$util.isFunction(something)) {\n    return $pDrw$var$util.inspect(something);\n  }\n\n  var rawname = $pDrw$var$getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' + name + ']';\n}\n\nfunction $pDrw$var$getMessage(self) {\n  return $pDrw$var$truncate($pDrw$var$inspect(self.actual), 128) + ' ' + self.operator + ' ' + $pDrw$var$truncate($pDrw$var$inspect(self.expected), 128);\n} // At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\n\nfunction $pDrw$var$fail(actual, expected, message, operator, stackStartFunction) {\n  throw new $pDrw$var$assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n} // EXTENSION! allows for well behaved errors defined elsewhere.\n\n\n$pDrw$var$assert.fail = $pDrw$var$fail; // 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction $pDrw$var$ok(value, message) {\n  if (!value) $pDrw$var$fail(value, true, message, '==', $pDrw$var$assert.ok);\n}\n\n$pDrw$var$assert.ok = $pDrw$var$ok; // 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\n$pDrw$var$assert.equal = function equal(actual, expected, message) {\n  if (actual != expected) $pDrw$var$fail(actual, expected, message, '==', $pDrw$var$assert.equal);\n}; // 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\n\n$pDrw$var$assert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    $pDrw$var$fail(actual, expected, message, '!=', $pDrw$var$assert.notEqual);\n  }\n}; // 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\n\n$pDrw$var$assert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!$pDrw$var$_deepEqual(actual, expected, false)) {\n    $pDrw$var$fail(actual, expected, message, 'deepEqual', $pDrw$var$assert.deepEqual);\n  }\n};\n\n$pDrw$var$assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!$pDrw$var$_deepEqual(actual, expected, true)) {\n    $pDrw$var$fail(actual, expected, message, 'deepStrictEqual', $pDrw$var$assert.deepStrictEqual);\n  }\n};\n\nfunction $pDrw$var$_deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if ($pDrw$var$isBuffer(actual) && $pDrw$var$isBuffer(expected)) {\n    return $pDrw$var$compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is\n    // equivalent if it is also a Date object that refers to the same time.\n  } else if ($pDrw$var$util.isDate(actual) && $pDrw$var$util.isDate(expected)) {\n    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is\n    // equivalent if it is also a RegExp object with the same source and\n    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if ($pDrw$var$util.isRegExp(actual) && $pDrw$var$util.isRegExp(expected)) {\n    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',\n    // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying\n    // ArrayBuffers in a Buffer each to increase performance\n    // This optimization requires the arrays to have the same type as checked by\n    // Object.prototype.toString (aka pToString). Never perform binary\n    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n    // bit patterns are not identical.\n  } else if ($pDrw$var$isView(actual) && $pDrw$var$isView(expected) && $pDrw$var$pToString(actual) === $pDrw$var$pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {\n    return $pDrw$var$compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n  } else if ($pDrw$var$isBuffer(actual) !== $pDrw$var$isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {\n      actual: [],\n      expected: []\n    };\n    var actualIndex = memos.actual.indexOf(actual);\n\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n    return $pDrw$var$objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction $pDrw$var$isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction $pDrw$var$objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same\n\n  if ($pDrw$var$util.isPrimitive(a) || $pDrw$var$util.isPrimitive(b)) return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;\n  var aIsArgs = $pDrw$var$isArguments(a);\n  var bIsArgs = $pDrw$var$isArguments(b);\n  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;\n\n  if (aIsArgs) {\n    a = $pDrw$var$pSlice.call(a);\n    b = $pDrw$var$pSlice.call(b);\n    return $pDrw$var$_deepEqual(a, b, strict);\n  }\n\n  var ka = $pDrw$var$objectKeys(a);\n  var kb = $pDrw$var$objectKeys(b);\n  var key, i; // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n\n  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),\n\n  ka.sort();\n  kb.sort(); //~~~cheap key test\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) return false;\n  } //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!$pDrw$var$_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;\n  }\n\n  return true;\n} // 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\n\n$pDrw$var$assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if ($pDrw$var$_deepEqual(actual, expected, false)) {\n    $pDrw$var$fail(actual, expected, message, 'notDeepEqual', $pDrw$var$assert.notDeepEqual);\n  }\n};\n\n$pDrw$var$assert.notDeepStrictEqual = $pDrw$var$notDeepStrictEqual;\n\nfunction $pDrw$var$notDeepStrictEqual(actual, expected, message) {\n  if ($pDrw$var$_deepEqual(actual, expected, true)) {\n    $pDrw$var$fail(actual, expected, message, 'notDeepStrictEqual', $pDrw$var$notDeepStrictEqual);\n  }\n} // 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\n\n$pDrw$var$assert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    $pDrw$var$fail(actual, expected, message, '===', $pDrw$var$assert.strictEqual);\n  }\n}; // 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\n\n$pDrw$var$assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    $pDrw$var$fail(actual, expected, message, '!==', $pDrw$var$assert.notStrictEqual);\n  }\n};\n\nfunction $pDrw$var$expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction $pDrw$var$_tryBlock(block) {\n  var error;\n\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n}\n\nfunction $pDrw$var$_throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = $pDrw$var$_tryBlock(block);\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    $pDrw$var$fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && $pDrw$var$util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if (isUnwantedException && userProvidedMessage && $pDrw$var$expectedException(actual, expected) || isUnexpectedException) {\n    $pDrw$var$fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if (shouldThrow && actual && expected && !$pDrw$var$expectedException(actual, expected) || !shouldThrow && actual) {\n    throw actual;\n  }\n} // 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\n\n$pDrw$var$assert.throws = function (block,\n/*optional*/\nerror,\n/*optional*/\nmessage) {\n  $pDrw$var$_throws(true, block, error, message);\n}; // EXTENSION! This is annoying to write outside this module.\n\n\n$pDrw$var$assert.doesNotThrow = function (block,\n/*optional*/\nerror,\n/*optional*/\nmessage) {\n  $pDrw$var$_throws(false, block, error, message);\n};\n\n$pDrw$var$assert.ifError = function (err) {\n  if (err) throw err;\n}; // Expose a strict only variant of assert\n\n\nfunction $pDrw$var$strict(value, message) {\n  if (!value) $pDrw$var$fail(value, true, message, '==', $pDrw$var$strict);\n}\n\n$pDrw$var$assert.strict = $pDrw$var$objectAssign($pDrw$var$strict, $pDrw$var$assert, {\n  equal: $pDrw$var$assert.strictEqual,\n  deepEqual: $pDrw$var$assert.deepStrictEqual,\n  notEqual: $pDrw$var$assert.notStrictEqual,\n  notDeepEqual: $pDrw$var$assert.notDeepStrictEqual\n});\n$pDrw$var$assert.strict.strict = $pDrw$var$assert.strict;\n\nvar $pDrw$var$objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    if ($pDrw$var$hasOwn.call(obj, key)) keys.push(key);\n  }\n\n  return keys;\n};"},"sourceMaps":null,"error":null,"hash":"bab20a7e012f6d234906991b4edb7135","cacheData":{"env":{},"imports":{"$require$object-assign":["object-assign","*"],"$require$util/":["util/","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}