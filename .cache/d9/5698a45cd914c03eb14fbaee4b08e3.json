{"id":"BFKd","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\package.json","includedInParent":true,"mtime":1598465925074},{"name":"assert","loc":{"line":4,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\assert\\assert.js"},{"name":"pako/lib/zlib/zstream","loc":{"line":6,"column":22},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\node_modules\\pako\\lib\\zlib\\zstream.js"},{"name":"pako/lib/zlib/deflate.js","loc":{"line":7,"column":27},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\node_modules\\pako\\lib\\zlib\\deflate.js"},{"name":"pako/lib/zlib/inflate.js","loc":{"line":8,"column":27},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\node_modules\\pako\\lib\\zlib\\inflate.js"},{"name":"pako/lib/zlib/constants","loc":{"line":9,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\node_modules\\pako\\lib\\zlib\\constants.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-zlib\\lib\\binding.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"var $BFKd$exports = {};\nvar $BFKd$var$process = $parcel$require(\"BFKd\", \"process\");\nvar $BFKd$var$Buffer = $parcel$require(\"BFKd\", \"buffer\").Buffer;\n\n/* eslint camelcase: \"off\" */\nvar $BFKd$var$assert = $parcel$require(\"BFKd\", \"assert\");\nvar $BFKd$var$Zstream = $parcel$require(\"BFKd\", \"pako/lib/zlib/zstream\");\nvar $BFKd$var$zlib_deflate = $parcel$require(\"BFKd\", \"pako/lib/zlib/deflate.js\");\nvar $BFKd$var$zlib_inflate = $parcel$require(\"BFKd\", \"pako/lib/zlib/inflate.js\");\nvar $BFKd$var$constants = $parcel$require(\"BFKd\", \"pako/lib/zlib/constants\");\n\nfor (var $BFKd$var$key in $BFKd$var$constants) {\n  $BFKd$exports[$BFKd$var$key] = $BFKd$var$constants[$BFKd$var$key];\n} // zlib modes\n\n\nvar $BFKd$export$NONE = 0;\n$BFKd$exports.NONE = $BFKd$export$NONE;\nvar $BFKd$export$DEFLATE = 1;\n$BFKd$exports.DEFLATE = $BFKd$export$DEFLATE;\nvar $BFKd$export$INFLATE = 2;\n$BFKd$exports.INFLATE = $BFKd$export$INFLATE;\nvar $BFKd$export$GZIP = 3;\n$BFKd$exports.GZIP = $BFKd$export$GZIP;\nvar $BFKd$export$GUNZIP = 4;\n$BFKd$exports.GUNZIP = $BFKd$export$GUNZIP;\nvar $BFKd$export$DEFLATERAW = 5;\n$BFKd$exports.DEFLATERAW = $BFKd$export$DEFLATERAW;\nvar $BFKd$export$INFLATERAW = 6;\n$BFKd$exports.INFLATERAW = $BFKd$export$INFLATERAW;\nvar $BFKd$export$UNZIP = 7;\n$BFKd$exports.UNZIP = $BFKd$export$UNZIP;\nvar $BFKd$var$GZIP_HEADER_ID1 = 0x1f;\nvar $BFKd$var$GZIP_HEADER_ID2 = 0x8b;\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\n\nfunction $BFKd$var$Zlib(mode) {\n  if (typeof mode !== 'number' || mode < $BFKd$exports.DEFLATE || mode > $BFKd$exports.UNZIP) {\n    throw new TypeError('Bad argument');\n  }\n\n  this.dictionary = null;\n  this.err = 0;\n  this.flush = 0;\n  this.init_done = false;\n  this.level = 0;\n  this.memLevel = 0;\n  this.mode = mode;\n  this.strategy = 0;\n  this.windowBits = 0;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.gzip_id_bytes_read = 0;\n}\n\n$BFKd$var$Zlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n  $BFKd$var$assert(this.init_done, 'close before init');\n  $BFKd$var$assert(this.mode <= $BFKd$exports.UNZIP);\n\n  if (this.mode === $BFKd$exports.DEFLATE || this.mode === $BFKd$exports.GZIP || this.mode === $BFKd$exports.DEFLATERAW) {\n    $BFKd$var$zlib_deflate.deflateEnd(this.strm);\n  } else if (this.mode === $BFKd$exports.INFLATE || this.mode === $BFKd$exports.GUNZIP || this.mode === $BFKd$exports.INFLATERAW || this.mode === $BFKd$exports.UNZIP) {\n    $BFKd$var$zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = $BFKd$exports.NONE;\n  this.dictionary = null;\n};\n\n$BFKd$var$Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\n$BFKd$var$Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\n$BFKd$var$Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n  $BFKd$var$assert.equal(arguments.length, 8);\n  $BFKd$var$assert(this.init_done, 'write before init');\n  $BFKd$var$assert(this.mode !== $BFKd$exports.NONE, 'already finalized');\n  $BFKd$var$assert.equal(false, this.write_in_progress, 'write already in progress');\n  $BFKd$var$assert.equal(false, this.pending_close, 'close is pending');\n  this.write_in_progress = true;\n  $BFKd$var$assert.equal(false, flush === undefined, 'must provide flush value');\n  this.write_in_progress = true;\n\n  if (flush !== $BFKd$exports.Z_NO_FLUSH && flush !== $BFKd$exports.Z_PARTIAL_FLUSH && flush !== $BFKd$exports.Z_SYNC_FLUSH && flush !== $BFKd$exports.Z_FULL_FLUSH && flush !== $BFKd$exports.Z_FINISH && flush !== $BFKd$exports.Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = $BFKd$var$Buffer.alloc(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  this.strm.avail_in = in_len;\n  this.strm.input = input;\n  this.strm.next_in = in_off;\n  this.strm.avail_out = out_len;\n  this.strm.output = out;\n  this.strm.next_out = out_off;\n  this.flush = flush;\n\n  if (!async) {\n    // sync version\n    this._process();\n\n    if (this._checkError()) {\n      return this._afterSync();\n    }\n\n    return;\n  } // async version\n\n\n  var self = this;\n  $BFKd$var$process.nextTick(function () {\n    self._process();\n\n    self._after();\n  });\n  return this;\n};\n\n$BFKd$var$Zlib.prototype._afterSync = function () {\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n  this.write_in_progress = false;\n  return [avail_in, avail_out];\n};\n\n$BFKd$var$Zlib.prototype._process = function () {\n  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out\n  // of room.  If there was avail_out left over, then it means\n  // that all of the input was consumed.\n\n  switch (this.mode) {\n    case $BFKd$exports.DEFLATE:\n    case $BFKd$exports.GZIP:\n    case $BFKd$exports.DEFLATERAW:\n      this.err = $BFKd$var$zlib_deflate.deflate(this.strm, this.flush);\n      break;\n\n    case $BFKd$exports.UNZIP:\n      if (this.strm.avail_in > 0) {\n        next_expected_header_byte = this.strm.next_in;\n      }\n\n      switch (this.gzip_id_bytes_read) {\n        case 0:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === $BFKd$var$GZIP_HEADER_ID1) {\n            this.gzip_id_bytes_read = 1;\n            next_expected_header_byte++;\n\n            if (this.strm.avail_in === 1) {\n              // The only available byte was already read.\n              break;\n            }\n          } else {\n            this.mode = $BFKd$exports.INFLATE;\n            break;\n          }\n\n        // fallthrough\n\n        case 1:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === $BFKd$var$GZIP_HEADER_ID2) {\n            this.gzip_id_bytes_read = 2;\n            this.mode = $BFKd$exports.GUNZIP;\n          } else {\n            // There is no actual difference between INFLATE and INFLATERAW\n            // (after initialization).\n            this.mode = $BFKd$exports.INFLATE;\n          }\n\n          break;\n\n        default:\n          throw new Error('invalid number of gzip magic number bytes read');\n      }\n\n    // fallthrough\n\n    case $BFKd$exports.INFLATE:\n    case $BFKd$exports.GUNZIP:\n    case $BFKd$exports.INFLATERAW:\n      this.err = $BFKd$var$zlib_inflate.inflate(this.strm, this.flush // If data was encoded with dictionary\n      );\n\n      if (this.err === $BFKd$exports.Z_NEED_DICT && this.dictionary) {\n        // Load it\n        this.err = $BFKd$var$zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n\n        if (this.err === $BFKd$exports.Z_OK) {\n          // And try to decode again\n          this.err = $BFKd$var$zlib_inflate.inflate(this.strm, this.flush);\n        } else if (this.err === $BFKd$exports.Z_DATA_ERROR) {\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n          // Make it possible for After() to tell a bad dictionary from bad\n          // input.\n          this.err = $BFKd$exports.Z_NEED_DICT;\n        }\n      }\n\n      while (this.strm.avail_in > 0 && this.mode === $BFKd$exports.GUNZIP && this.err === $BFKd$exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\n        // Bytes remain in input buffer. Perhaps this is another compressed\n        // member in the same archive, or just trailing garbage.\n        // Trailing zero bytes are okay, though, since they are frequently\n        // used for padding.\n        this.reset();\n        this.err = $BFKd$var$zlib_inflate.inflate(this.strm, this.flush);\n      }\n\n      break;\n\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n};\n\n$BFKd$var$Zlib.prototype._checkError = function () {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (this.err) {\n    case $BFKd$exports.Z_OK:\n    case $BFKd$exports.Z_BUF_ERROR:\n      if (this.strm.avail_out !== 0 && this.flush === $BFKd$exports.Z_FINISH) {\n        this._error('unexpected end of file');\n\n        return false;\n      }\n\n      break;\n\n    case $BFKd$exports.Z_STREAM_END:\n      // normal statuses, not fatal\n      break;\n\n    case $BFKd$exports.Z_NEED_DICT:\n      if (this.dictionary == null) {\n        this._error('Missing dictionary');\n      } else {\n        this._error('Bad dictionary');\n      }\n\n      return false;\n\n    default:\n      // something else.\n      this._error('Zlib error');\n\n      return false;\n  }\n\n  return true;\n};\n\n$BFKd$var$Zlib.prototype._after = function () {\n  if (!this._checkError()) {\n    return;\n  }\n\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n  this.write_in_progress = false; // call the write() cb\n\n  this.callback(avail_in, avail_out);\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\n$BFKd$var$Zlib.prototype._error = function (message) {\n  if (this.strm.msg) {\n    message = this.strm.msg;\n  }\n\n  this.onerror(message, this.err // no hope of rescue.\n  );\n  this.write_in_progress = false;\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\n$BFKd$var$Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  $BFKd$var$assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\n  $BFKd$var$assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\n  $BFKd$var$assert(level >= -1 && level <= 9, 'invalid compression level');\n  $BFKd$var$assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\n  $BFKd$var$assert(strategy === $BFKd$exports.Z_FILTERED || strategy === $BFKd$exports.Z_HUFFMAN_ONLY || strategy === $BFKd$exports.Z_RLE || strategy === $BFKd$exports.Z_FIXED || strategy === $BFKd$exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\n\n  this._init(level, windowBits, memLevel, strategy, dictionary);\n\n  this._setDictionary();\n};\n\n$BFKd$var$Zlib.prototype.params = function () {\n  throw new Error('deflateParams Not supported');\n};\n\n$BFKd$var$Zlib.prototype.reset = function () {\n  this._reset();\n\n  this._setDictionary();\n};\n\n$BFKd$var$Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n  this.level = level;\n  this.windowBits = windowBits;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n  this.flush = $BFKd$exports.Z_NO_FLUSH;\n  this.err = $BFKd$exports.Z_OK;\n\n  if (this.mode === $BFKd$exports.GZIP || this.mode === $BFKd$exports.GUNZIP) {\n    this.windowBits += 16;\n  }\n\n  if (this.mode === $BFKd$exports.UNZIP) {\n    this.windowBits += 32;\n  }\n\n  if (this.mode === $BFKd$exports.DEFLATERAW || this.mode === $BFKd$exports.INFLATERAW) {\n    this.windowBits = -1 * this.windowBits;\n  }\n\n  this.strm = new $BFKd$var$Zstream();\n\n  switch (this.mode) {\n    case $BFKd$exports.DEFLATE:\n    case $BFKd$exports.GZIP:\n    case $BFKd$exports.DEFLATERAW:\n      this.err = $BFKd$var$zlib_deflate.deflateInit2(this.strm, this.level, $BFKd$exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n\n    case $BFKd$exports.INFLATE:\n    case $BFKd$exports.GUNZIP:\n    case $BFKd$exports.INFLATERAW:\n    case $BFKd$exports.UNZIP:\n      this.err = $BFKd$var$zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (this.err !== $BFKd$exports.Z_OK) {\n    this._error('Init error');\n  }\n\n  this.dictionary = dictionary;\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\n$BFKd$var$Zlib.prototype._setDictionary = function () {\n  if (this.dictionary == null) {\n    return;\n  }\n\n  this.err = $BFKd$exports.Z_OK;\n\n  switch (this.mode) {\n    case $BFKd$exports.DEFLATE:\n    case $BFKd$exports.DEFLATERAW:\n      this.err = $BFKd$var$zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n      break;\n\n    default:\n      break;\n  }\n\n  if (this.err !== $BFKd$exports.Z_OK) {\n    this._error('Failed to set dictionary');\n  }\n};\n\n$BFKd$var$Zlib.prototype._reset = function () {\n  this.err = $BFKd$exports.Z_OK;\n\n  switch (this.mode) {\n    case $BFKd$exports.DEFLATE:\n    case $BFKd$exports.DEFLATERAW:\n    case $BFKd$exports.GZIP:\n      this.err = $BFKd$var$zlib_deflate.deflateReset(this.strm);\n      break;\n\n    case $BFKd$exports.INFLATE:\n    case $BFKd$exports.INFLATERAW:\n    case $BFKd$exports.GUNZIP:\n      this.err = $BFKd$var$zlib_inflate.inflateReset(this.strm);\n      break;\n\n    default:\n      break;\n  }\n\n  if (this.err !== $BFKd$exports.Z_OK) {\n    this._error('Failed to reset stream');\n  }\n};\n\nvar $BFKd$export$Zlib = $BFKd$var$Zlib;\n$BFKd$exports.Zlib = $BFKd$export$Zlib;"},"sourceMaps":null,"error":null,"hash":"15a033803c146d090c54be843efa012c","cacheData":{"env":{},"imports":{"$require$assert":["assert","*"],"$require$pako/lib/zlib/zstream":["pako/lib/zlib/zstream","*"],"$require$pako/lib/zlib/deflate.js":["pako/lib/zlib/deflate.js","*"],"$require$pako/lib/zlib/inflate.js":["pako/lib/zlib/inflate.js","*"],"$require$pako/lib/zlib/constants":["pako/lib/zlib/constants","*"],"$require$buffer":["buffer","*"],"$require$process":["process","*"]},"exports":{"NONE":"$BFKd$export$NONE","DEFLATE":"$BFKd$export$DEFLATE","INFLATE":"$BFKd$export$INFLATE","GZIP":"$BFKd$export$GZIP","GUNZIP":"$BFKd$export$GUNZIP","DEFLATERAW":"$BFKd$export$DEFLATERAW","INFLATERAW":"$BFKd$export$INFLATERAW","UNZIP":"$BFKd$export$UNZIP","Zlib":"$BFKd$export$Zlib"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}