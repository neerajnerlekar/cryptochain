{"id":"ZoIM","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\package.json","includedInParent":true,"mtime":1598465911285},{"name":"hash.js","loc":{"line":3,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash.js\\lib\\hash.js"},{"name":"../curves","loc":{"line":4,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\curves.js"},{"name":"../utils","loc":{"line":5,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\utils.js"},{"name":"./key","loc":{"line":8,"column":22},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\key.js"},{"name":"./signature","loc":{"line":9,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\create-ecdh\\node_modules\\elliptic\\lib\\elliptic\\eddsa\\signature.js"}],"generated":{"js":"var $ZoIM$exports = {};\nvar $ZoIM$var$hash = $parcel$require(\"ZoIM\", \"hash.js\");\nvar $ZoIM$var$curves = $parcel$require(\"ZoIM\", \"../curves\");\nvar $ZoIM$var$utils = $parcel$require(\"ZoIM\", \"../utils\");\nvar $ZoIM$var$assert = $ZoIM$var$utils.assert;\nvar $ZoIM$var$parseBytes = $ZoIM$var$utils.parseBytes;\nvar $ZoIM$var$KeyPair = $parcel$require(\"ZoIM\", \"./key\");\nvar $ZoIM$var$Signature = $parcel$require(\"ZoIM\", \"./signature\");\n\nfunction $ZoIM$var$EDDSA(curve) {\n  $ZoIM$var$assert(curve === 'ed25519', 'only tested with ed25519 so far');\n  if (!(this instanceof $ZoIM$var$EDDSA)) return new $ZoIM$var$EDDSA(curve);\n  var curve = $ZoIM$var$curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = $ZoIM$var$hash.sha512;\n}\n\n$ZoIM$exports = $ZoIM$var$EDDSA;\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\n\n$ZoIM$var$EDDSA.prototype.sign = function sign(message, secret) {\n  message = $ZoIM$var$parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({\n    R: R,\n    S: S,\n    Rencoded: Rencoded\n  });\n};\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\n\n\n$ZoIM$var$EDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = $ZoIM$var$parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\n$ZoIM$var$EDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n\n  for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);\n\n  return $ZoIM$var$utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\n$ZoIM$var$EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return $ZoIM$var$KeyPair.fromPublic(this, pub);\n};\n\n$ZoIM$var$EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return $ZoIM$var$KeyPair.fromSecret(this, secret);\n};\n\n$ZoIM$var$EDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof $ZoIM$var$Signature) return sig;\n  return new $ZoIM$var$Signature(this, sig);\n};\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\n\n\n$ZoIM$var$EDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\n$ZoIM$var$EDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = $ZoIM$var$utils.parseBytes(bytes);\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n  var y = $ZoIM$var$utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\n$ZoIM$var$EDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\n$ZoIM$var$EDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return $ZoIM$var$utils.intFromLE(bytes);\n};\n\n$ZoIM$var$EDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};"},"sourceMaps":null,"error":null,"hash":"a981f3153fc89d0ade37e7f4d8a8399d","cacheData":{"env":{},"imports":{"$require$hash.js":["hash.js","*"],"$require$../curves":["../curves","*"],"$require$../utils":["../utils","*"],"$require$./key":["./key","*"],"$require$./signature":["./signature","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}