{"id":"veXI","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\package.json","includedInParent":true,"mtime":1598465888624},{"name":"debug","loc":{"line":14,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\debug\\src\\browser.js"},{"name":"encodeurl","loc":{"line":15,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\encodeurl\\index.js"},{"name":"escape-html","loc":{"line":16,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\escape-html\\index.js"},{"name":"on-finished","loc":{"line":17,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\on-finished\\index.js"},{"name":"parseurl","loc":{"line":18,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\parseurl\\index.js"},{"name":"statuses","loc":{"line":19,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\statuses\\index.js"},{"name":"unpipe","loc":{"line":20,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\unpipe\\index.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\finalhandler\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $veXI$exports = {};\nvar $veXI$var$Buffer = $parcel$require(\"veXI\", \"buffer\").Buffer;\nvar $veXI$var$process = $parcel$require(\"veXI\", \"process\");\n\n/**\n * Module dependencies.\n * @private\n */\nvar $veXI$var$debug = $parcel$require(\"veXI\", \"debug\")('finalhandler');\nvar $veXI$var$encodeUrl = $parcel$require(\"veXI\", \"encodeurl\");\nvar $veXI$var$escapeHtml = $parcel$require(\"veXI\", \"escape-html\");\nvar $veXI$var$onFinished = $parcel$require(\"veXI\", \"on-finished\");\nvar $veXI$var$parseUrl = $parcel$require(\"veXI\", \"parseurl\");\nvar $veXI$var$statuses = $parcel$require(\"veXI\", \"statuses\");\nvar $veXI$var$unpipe = $parcel$require(\"veXI\", \"unpipe\");\n/**\n * Module variables.\n * @private\n */\n\nvar $veXI$var$DOUBLE_SPACE_REGEXP = /\\x20{2}/g;\nvar $veXI$var$NEWLINE_REGEXP = /\\n/g;\n/* istanbul ignore next */\n\nvar $veXI$var$defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  $veXI$var$process.nextTick(fn.bind.apply(fn, arguments));\n};\nvar $veXI$var$isFinished = $veXI$var$onFinished.isFinished;\n/**\n * Create a minimal HTML document.\n *\n * @param {string} message\n * @private\n */\n\nfunction $veXI$var$createHtmlDocument(message) {\n  var body = $veXI$var$escapeHtml(message).replace($veXI$var$NEWLINE_REGEXP, '<br>').replace($veXI$var$DOUBLE_SPACE_REGEXP, ' &nbsp;');\n  return '<!DOCTYPE html>\\n' + '<html lang=\"en\">\\n' + '<head>\\n' + '<meta charset=\"utf-8\">\\n' + '<title>Error</title>\\n' + '</head>\\n' + '<body>\\n' + '<pre>' + body + '</pre>\\n' + '</body>\\n' + '</html>\\n';\n}\n/**\n * Module exports.\n * @public\n */\n\n\n$veXI$exports = $veXI$var$finalhandler;\n/**\n * Create a function to handle the final response.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {Object} [options]\n * @return {Function}\n * @public\n */\n\nfunction $veXI$var$finalhandler(req, res, options) {\n  var opts = options || {}; // get environment\n\n  var env = opts.env || \"production\" || 'development'; // get error callback\n\n  var onerror = opts.onerror;\n  return function (err) {\n    var headers;\n    var msg;\n    var status; // ignore 404 on in-flight response\n\n    if (!err && $veXI$var$headersSent(res)) {\n      $veXI$var$debug('cannot 404 after headers sent');\n      return;\n    } // unhandled error\n\n\n    if (err) {\n      // respect status code from error\n      status = $veXI$var$getErrorStatusCode(err);\n\n      if (status === undefined) {\n        // fallback to status code on response\n        status = $veXI$var$getResponseStatusCode(res);\n      } else {\n        // respect headers from error\n        headers = $veXI$var$getErrorHeaders(err);\n      } // get error message\n\n\n      msg = $veXI$var$getErrorMessage(err, status, env);\n    } else {\n      // not found\n      status = 404;\n      msg = 'Cannot ' + req.method + ' ' + $veXI$var$encodeUrl($veXI$var$getResourceName(req));\n    }\n\n    $veXI$var$debug('default %s', status); // schedule onerror callback\n\n    if (err && onerror) {\n      $veXI$var$defer(onerror, err, req, res);\n    } // cannot actually respond\n\n\n    if ($veXI$var$headersSent(res)) {\n      $veXI$var$debug('cannot %d after headers sent', status);\n      req.socket.destroy();\n      return;\n    } // send response\n\n\n    $veXI$var$send(req, res, status, headers, msg);\n  };\n}\n/**\n * Get headers from Error object.\n *\n * @param {Error} err\n * @return {object}\n * @private\n */\n\n\nfunction $veXI$var$getErrorHeaders(err) {\n  if (!err.headers || typeof err.headers !== 'object') {\n    return undefined;\n  }\n\n  var headers = Object.create(null);\n  var keys = Object.keys(err.headers);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    headers[key] = err.headers[key];\n  }\n\n  return headers;\n}\n/**\n * Get message from Error object, fallback to status message.\n *\n * @param {Error} err\n * @param {number} status\n * @param {string} env\n * @return {string}\n * @private\n */\n\n\nfunction $veXI$var$getErrorMessage(err, status, env) {\n  var msg;\n\n  if (env !== 'production') {\n    // use err.stack, which typically includes err.message\n    msg = err.stack; // fallback to err.toString() when possible\n\n    if (!msg && typeof err.toString === 'function') {\n      msg = err.toString();\n    }\n  }\n\n  return msg || $veXI$var$statuses[status];\n}\n/**\n * Get status code from Error object.\n *\n * @param {Error} err\n * @return {number}\n * @private\n */\n\n\nfunction $veXI$var$getErrorStatusCode(err) {\n  // check err.status\n  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {\n    return err.status;\n  } // check err.statusCode\n\n\n  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {\n    return err.statusCode;\n  }\n\n  return undefined;\n}\n/**\n * Get resource name for the request.\n *\n * This is typically just the original pathname of the request\n * but will fallback to \"resource\" is that cannot be determined.\n *\n * @param {IncomingMessage} req\n * @return {string}\n * @private\n */\n\n\nfunction $veXI$var$getResourceName(req) {\n  try {\n    return $veXI$var$parseUrl.original(req).pathname;\n  } catch (e) {\n    return 'resource';\n  }\n}\n/**\n * Get status code from response.\n *\n * @param {OutgoingMessage} res\n * @return {number}\n * @private\n */\n\n\nfunction $veXI$var$getResponseStatusCode(res) {\n  var status = res.statusCode; // default status code to 500 if outside valid range\n\n  if (typeof status !== 'number' || status < 400 || status > 599) {\n    status = 500;\n  }\n\n  return status;\n}\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\n\nfunction $veXI$var$headersSent(res) {\n  return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;\n}\n/**\n * Send response.\n *\n * @param {IncomingMessage} req\n * @param {OutgoingMessage} res\n * @param {number} status\n * @param {object} headers\n * @param {string} message\n * @private\n */\n\n\nfunction $veXI$var$send(req, res, status, headers, message) {\n  function write() {\n    // response body\n    var body = $veXI$var$createHtmlDocument(message); // response status\n\n    res.statusCode = status;\n    res.statusMessage = $veXI$var$statuses[status]; // response headers\n\n    $veXI$var$setHeaders(res, headers); // security headers\n\n    res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n    res.setHeader('X-Content-Type-Options', 'nosniff'); // standard headers\n\n    res.setHeader('Content-Type', 'text/html; charset=utf-8');\n    res.setHeader('Content-Length', $veXI$var$Buffer.byteLength(body, 'utf8'));\n\n    if (req.method === 'HEAD') {\n      res.end();\n      return;\n    }\n\n    res.end(body, 'utf8');\n  }\n\n  if ($veXI$var$isFinished(req)) {\n    write();\n    return;\n  } // unpipe everything from the request\n\n\n  $veXI$var$unpipe(req); // flush the request\n\n  $veXI$var$onFinished(req, write);\n  req.resume();\n}\n/**\n * Set response headers from an object.\n *\n * @param {OutgoingMessage} res\n * @param {object} headers\n * @private\n */\n\n\nfunction $veXI$var$setHeaders(res, headers) {\n  if (!headers) {\n    return;\n  }\n\n  var keys = Object.keys(headers);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    res.setHeader(key, headers[key]);\n  }\n}"},"sourceMaps":null,"error":null,"hash":"ea822b0e300a169fc15dcff84d93162c","cacheData":{"env":{"NODE_ENV":"production"},"imports":{"$require$debug":["debug","*"],"$require$encodeurl":["encodeurl","*"],"$require$escape-html":["escape-html","*"],"$require$on-finished":["on-finished","*"],"$require$parseurl":["parseurl","*"],"$require$statuses":["statuses","*"],"$require$unpipe":["unpipe","*"],"$require$process":["process","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}