{"id":"QAnv","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\base64-js\\package.json","includedInParent":true,"mtime":1598465925603}],"generated":{"js":"var $QAnv$exports = {};\nvar $QAnv$export$byteLength = $QAnv$var$byteLength;\n$QAnv$exports.byteLength = $QAnv$export$byteLength;\nvar $QAnv$export$toByteArray = $QAnv$var$toByteArray;\n$QAnv$exports.toByteArray = $QAnv$export$toByteArray;\nvar $QAnv$export$fromByteArray = $QAnv$var$fromByteArray;\n$QAnv$exports.fromByteArray = $QAnv$export$fromByteArray;\nvar $QAnv$var$lookup = [];\nvar $QAnv$var$revLookup = [];\nvar $QAnv$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar $QAnv$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var $QAnv$var$i = 0, $QAnv$var$len = $QAnv$var$code.length; $QAnv$var$i < $QAnv$var$len; ++$QAnv$var$i) {\n  $QAnv$var$lookup[$QAnv$var$i] = $QAnv$var$code[$QAnv$var$i];\n  $QAnv$var$revLookup[$QAnv$var$code.charCodeAt($QAnv$var$i)] = $QAnv$var$i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n$QAnv$var$revLookup['-'.charCodeAt(0)] = 62;\n$QAnv$var$revLookup['_'.charCodeAt(0)] = 63;\n\nfunction $QAnv$var$getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction $QAnv$var$byteLength(b64) {\n  var lens = $QAnv$var$getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction $QAnv$var$_byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction $QAnv$var$toByteArray(b64) {\n  var tmp;\n  var lens = $QAnv$var$getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new $QAnv$var$Arr($QAnv$var$_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = $QAnv$var$revLookup[b64.charCodeAt(i)] << 18 | $QAnv$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $QAnv$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $QAnv$var$revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = $QAnv$var$revLookup[b64.charCodeAt(i)] << 2 | $QAnv$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = $QAnv$var$revLookup[b64.charCodeAt(i)] << 10 | $QAnv$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $QAnv$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction $QAnv$var$tripletToBase64(num) {\n  return $QAnv$var$lookup[num >> 18 & 0x3F] + $QAnv$var$lookup[num >> 12 & 0x3F] + $QAnv$var$lookup[num >> 6 & 0x3F] + $QAnv$var$lookup[num & 0x3F];\n}\n\nfunction $QAnv$var$encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push($QAnv$var$tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction $QAnv$var$fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push($QAnv$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push($QAnv$var$lookup[tmp >> 2] + $QAnv$var$lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push($QAnv$var$lookup[tmp >> 10] + $QAnv$var$lookup[tmp >> 4 & 0x3F] + $QAnv$var$lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}"},"sourceMaps":null,"error":null,"hash":"84e19d323b37d3266fd64a83ba2e42ff","cacheData":{"env":{},"imports":{},"exports":{"byteLength":"$QAnv$export$byteLength","toByteArray":"$QAnv$export$toByteArray","fromByteArray":"$QAnv$export$fromByteArray"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}