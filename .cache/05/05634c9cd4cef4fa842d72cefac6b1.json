{"id":"BBXB","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\package.json","includedInParent":true,"mtime":1598465887062},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"var $BBXB$exports = {};\nvar $BBXB$var$process = $parcel$require(\"BBXB\", \"process\");\n\n// undocumented cb() API, needed for core, not for public API\nfunction $BBXB$var$destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        $BBXB$var$process.nextTick($BBXB$var$emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        $BBXB$var$process.nextTick($BBXB$var$emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        $BBXB$var$process.nextTick($BBXB$var$emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        $BBXB$var$process.nextTick($BBXB$var$emitErrorAndCloseNT, _this, err);\n      } else {\n        $BBXB$var$process.nextTick($BBXB$var$emitCloseNT, _this);\n      }\n    } else if (cb) {\n      $BBXB$var$process.nextTick($BBXB$var$emitCloseNT, _this);\n      cb(err);\n    } else {\n      $BBXB$var$process.nextTick($BBXB$var$emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction $BBXB$var$emitErrorAndCloseNT(self, err) {\n  $BBXB$var$emitErrorNT(self, err);\n  $BBXB$var$emitCloseNT(self);\n}\n\nfunction $BBXB$var$emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction $BBXB$var$undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction $BBXB$var$emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction $BBXB$var$errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\n$BBXB$exports = {\n  destroy: $BBXB$var$destroy,\n  undestroy: $BBXB$var$undestroy,\n  errorOrDestroy: $BBXB$var$errorOrDestroy\n};"},"sourceMaps":null,"error":null,"hash":"1b07395986317fd787266f377a833ccf","cacheData":{"env":{},"imports":{"$require$process":["process","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}