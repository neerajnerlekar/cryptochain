{"id":"Xugw","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\package.json","includedInParent":true,"mtime":1598465888841},{"name":"bytes","loc":{"line":15,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\bytes\\index.js"},{"name":"http-errors","loc":{"line":16,"column":26},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\node_modules\\http-errors\\index.js"},{"name":"iconv-lite","loc":{"line":17,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\iconv-lite\\lib\\index.js"},{"name":"unpipe","loc":{"line":18,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\unpipe\\index.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"},{"name":"buffer","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\raw-body\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\buffer\\index.js"}],"generated":{"js":"var $Xugw$exports = {};\nvar $Xugw$var$Buffer = $parcel$require(\"Xugw\", \"buffer\").Buffer;\nvar $Xugw$var$process = $parcel$require(\"Xugw\", \"process\");\n\n/**\n * Module dependencies.\n * @private\n */\nvar $Xugw$var$bytes = $parcel$require(\"Xugw\", \"bytes\");\nvar $Xugw$var$createError = $parcel$require(\"Xugw\", \"http-errors\");\nvar $Xugw$var$iconv = $parcel$require(\"Xugw\", \"iconv-lite\");\nvar $Xugw$var$unpipe = $parcel$require(\"Xugw\", \"unpipe\");\n/**\n * Module exports.\n * @public\n */\n\n$Xugw$exports = $Xugw$var$getRawBody;\n/**\n * Module variables.\n * @private\n */\n\nvar $Xugw$var$ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction $Xugw$var$getDecoder(encoding) {\n  if (!encoding) return null;\n\n  try {\n    return $Xugw$var$iconv.getDecoder(encoding);\n  } catch (e) {\n    // error getting decoder\n    if (!$Xugw$var$ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e; // the encoding was not found\n\n    throw $Xugw$var$createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n}\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\n\nfunction $Xugw$var$getRawBody(stream, options, callback) {\n  var done = callback;\n  var opts = options || {};\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    };\n  }\n\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  } // validate callback is a function, if provided\n\n\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  } // require the callback without promises\n\n\n  if (!done && !$parcel$global.Promise) {\n    throw new TypeError('argument callback is required');\n  } // get encoding\n\n\n  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8'; // convert the limit to an integer\n\n  var limit = $Xugw$var$bytes.parse(opts.limit); // convert the expected length to an integer\n\n  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;\n\n  if (done) {\n    // classic callback style\n    return $Xugw$var$readStream(stream, encoding, length, limit, done);\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    $Xugw$var$readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err);\n      resolve(buf);\n    });\n  });\n}\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\n\nfunction $Xugw$var$halt(stream) {\n  // unpipe everything from the stream\n  $Xugw$var$unpipe(stream); // pause stream\n\n  if (typeof stream.pause === 'function') {\n    stream.pause();\n  }\n}\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\n\nfunction $Xugw$var$readStream(stream, encoding, length, limit, callback) {\n  var complete = false;\n  var sync = true; // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n\n  if (limit !== null && length !== null && length > limit) {\n    return done($Xugw$var$createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }));\n  } // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n\n\n  var state = stream._readableState;\n\n  if (stream._decoder || state && (state.encoding || state.decoder)) {\n    // developer error\n    return done($Xugw$var$createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }));\n  }\n\n  var received = 0;\n  var decoder;\n\n  try {\n    decoder = $Xugw$var$getDecoder(encoding);\n  } catch (err) {\n    return done(err);\n  }\n\n  var buffer = decoder ? '' : []; // attach listeners\n\n  stream.on('aborted', onAborted);\n  stream.on('close', cleanup);\n  stream.on('data', onData);\n  stream.on('end', onEnd);\n  stream.on('error', onEnd); // mark sync section complete\n\n  sync = false;\n\n  function done() {\n    var args = new Array(arguments.length); // copy arguments\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    } // mark complete\n\n\n    complete = true;\n\n    if (sync) {\n      $Xugw$var$process.nextTick(invokeCallback);\n    } else {\n      invokeCallback();\n    }\n\n    function invokeCallback() {\n      cleanup();\n\n      if (args[0]) {\n        // halt the stream on error\n        $Xugw$var$halt(stream);\n      }\n\n      callback.apply(null, args);\n    }\n  }\n\n  function onAborted() {\n    if (complete) return;\n    done($Xugw$var$createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }));\n  }\n\n  function onData(chunk) {\n    if (complete) return;\n    received += chunk.length;\n\n    if (limit !== null && received > limit) {\n      done($Xugw$var$createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }));\n    } else if (decoder) {\n      buffer += decoder.write(chunk);\n    } else {\n      buffer.push(chunk);\n    }\n  }\n\n  function onEnd(err) {\n    if (complete) return;\n    if (err) return done(err);\n\n    if (length !== null && received !== length) {\n      done($Xugw$var$createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }));\n    } else {\n      var string = decoder ? buffer + (decoder.end() || '') : $Xugw$var$Buffer.concat(buffer);\n      done(null, string);\n    }\n  }\n\n  function cleanup() {\n    buffer = null;\n    stream.removeListener('aborted', onAborted);\n    stream.removeListener('data', onData);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('error', onEnd);\n    stream.removeListener('close', cleanup);\n  }\n}"},"sourceMaps":null,"error":null,"hash":"8b8d5afdff1eefdd83af6c9c7c7aa145","cacheData":{"env":{},"imports":{"$require$bytes":["bytes","*"],"$require$http-errors":["http-errors","*"],"$require$iconv-lite":["iconv-lite","*"],"$require$unpipe":["unpipe","*"],"$require$process":["process","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}