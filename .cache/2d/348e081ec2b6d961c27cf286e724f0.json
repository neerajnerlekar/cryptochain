{"id":"cZBQ","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\package.json","includedInParent":true,"mtime":1598465886487},{"name":"./authCipher","loc":{"line":1,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\authCipher.js"},{"name":"safe-buffer","loc":{"line":2,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\safe-buffer\\index.js"},{"name":"./modes","loc":{"line":3,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\modes\\index.js"},{"name":"./streamCipher","loc":{"line":4,"column":27},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\streamCipher.js"},{"name":"cipher-base","loc":{"line":5,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\cipher-base\\index.js"},{"name":"./aes","loc":{"line":6,"column":18},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\aes.js"},{"name":"evp_bytestokey","loc":{"line":7,"column":19},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\evp_bytestokey\\index.js"},{"name":"inherits","loc":{"line":8,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\browserify-aes\\decrypter.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"}],"generated":{"js":"\nvar $cZBQ$exports = {};\nvar $cZBQ$var$AuthCipher = $parcel$require(\"cZBQ\", \"./authCipher\");\nvar $cZBQ$var$Buffer = $parcel$require(\"cZBQ\", \"safe-buffer\").Buffer;\nvar $cZBQ$var$MODES = $parcel$require(\"cZBQ\", \"./modes\");\nvar $cZBQ$var$StreamCipher = $parcel$require(\"cZBQ\", \"./streamCipher\");\nvar $cZBQ$var$Transform = $parcel$require(\"cZBQ\", \"cipher-base\");\nvar $cZBQ$var$aes = $parcel$require(\"cZBQ\", \"./aes\");\nvar $cZBQ$var$ebtk = $parcel$require(\"cZBQ\", \"evp_bytestokey\");\nvar $cZBQ$var$inherits = $parcel$require(\"cZBQ\", \"inherits\");\n\nfunction $cZBQ$var$Decipher(mode, key, iv) {\n  $cZBQ$var$Transform.call(this);\n  this._cache = new $cZBQ$var$Splitter();\n  this._last = void 0;\n  this._cipher = new $cZBQ$var$aes.AES(key);\n  this._prev = $cZBQ$var$Buffer.from(iv);\n  this._mode = mode;\n  this._autopadding = true;\n}\n\n$cZBQ$var$inherits($cZBQ$var$Decipher, $cZBQ$var$Transform);\n\n$cZBQ$var$Decipher.prototype._update = function (data) {\n  this._cache.add(data);\n\n  var chunk;\n  var thing;\n  var out = [];\n\n  while (chunk = this._cache.get(this._autopadding)) {\n    thing = this._mode.decrypt(this, chunk);\n    out.push(thing);\n  }\n\n  return $cZBQ$var$Buffer.concat(out);\n};\n\n$cZBQ$var$Decipher.prototype._final = function () {\n  var chunk = this._cache.flush();\n\n  if (this._autopadding) {\n    return $cZBQ$var$unpad(this._mode.decrypt(this, chunk));\n  } else if (chunk) {\n    throw new Error('data not multiple of block length');\n  }\n};\n\n$cZBQ$var$Decipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo;\n  return this;\n};\n\nfunction $cZBQ$var$Splitter() {\n  this.cache = $cZBQ$var$Buffer.allocUnsafe(0);\n}\n\n$cZBQ$var$Splitter.prototype.add = function (data) {\n  this.cache = $cZBQ$var$Buffer.concat([this.cache, data]);\n};\n\n$cZBQ$var$Splitter.prototype.get = function (autoPadding) {\n  var out;\n\n  if (autoPadding) {\n    if (this.cache.length > 16) {\n      out = this.cache.slice(0, 16);\n      this.cache = this.cache.slice(16);\n      return out;\n    }\n  } else {\n    if (this.cache.length >= 16) {\n      out = this.cache.slice(0, 16);\n      this.cache = this.cache.slice(16);\n      return out;\n    }\n  }\n\n  return null;\n};\n\n$cZBQ$var$Splitter.prototype.flush = function () {\n  if (this.cache.length) return this.cache;\n};\n\nfunction $cZBQ$var$unpad(last) {\n  var padded = last[15];\n\n  if (padded < 1 || padded > 16) {\n    throw new Error('unable to decrypt data');\n  }\n\n  var i = -1;\n\n  while (++i < padded) {\n    if (last[i + (16 - padded)] !== padded) {\n      throw new Error('unable to decrypt data');\n    }\n  }\n\n  if (padded === 16) return;\n  return last.slice(0, 16 - padded);\n}\n\nfunction $cZBQ$var$createDecipheriv(suite, password, iv) {\n  var config = $cZBQ$var$MODES[suite.toLowerCase()];\n  if (!config) throw new TypeError('invalid suite type');\n  if (typeof iv === 'string') iv = $cZBQ$var$Buffer.from(iv);\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);\n  if (typeof password === 'string') password = $cZBQ$var$Buffer.from(password);\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);\n\n  if (config.type === 'stream') {\n    return new $cZBQ$var$StreamCipher(config.module, password, iv, true);\n  } else if (config.type === 'auth') {\n    return new $cZBQ$var$AuthCipher(config.module, password, iv, true);\n  }\n\n  return new $cZBQ$var$Decipher(config.module, password, iv);\n}\n\nfunction $cZBQ$var$createDecipher(suite, password) {\n  var config = $cZBQ$var$MODES[suite.toLowerCase()];\n  if (!config) throw new TypeError('invalid suite type');\n  var keys = $cZBQ$var$ebtk(password, false, config.key, config.iv);\n  return $cZBQ$var$createDecipheriv(suite, keys.key, keys.iv);\n}\n\nvar $cZBQ$export$createDecipher = $cZBQ$var$createDecipher;\n$cZBQ$exports.createDecipher = $cZBQ$export$createDecipher;\nvar $cZBQ$export$createDecipheriv = $cZBQ$var$createDecipheriv;\n$cZBQ$exports.createDecipheriv = $cZBQ$export$createDecipheriv;"},"sourceMaps":null,"error":null,"hash":"f5e2f31f8eb2fb64d2a0df86cf57e646","cacheData":{"env":{},"imports":{"$require$./authCipher":["./authCipher","*"],"$require$safe-buffer":["safe-buffer","*"],"$require$./modes":["./modes","*"],"$require$./streamCipher":["./streamCipher","*"],"$require$cipher-base":["cipher-base","*"],"$require$./aes":["./aes","*"],"$require$evp_bytestokey":["evp_bytestokey","*"],"$require$inherits":["inherits","*"]},"exports":{"createDecipher":"$cZBQ$export$createDecipher","createDecipheriv":"$cZBQ$export$createDecipheriv"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}