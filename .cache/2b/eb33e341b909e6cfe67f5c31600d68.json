{"id":"LFsm","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\express\\node_modules\\qs\\package.json","includedInParent":true,"mtime":1598465921227}],"generated":{"js":"var $LFsm$exports = {};\nvar $LFsm$var$has = Object.prototype.hasOwnProperty;\n\nvar $LFsm$var$hexTable = function () {\n  var array = [];\n\n  for (var i = 0; i < 256; ++i) {\n    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n  }\n\n  return array;\n}();\n\nvar $LFsm$var$compactQueue = function compactQueue(queue) {\n  var obj;\n\n  while (queue.length) {\n    var item = queue.pop();\n    obj = item.obj[item.prop];\n\n    if (Array.isArray(obj)) {\n      var compacted = [];\n\n      for (var j = 0; j < obj.length; ++j) {\n        if (typeof obj[j] !== 'undefined') {\n          compacted.push(obj[j]);\n        }\n      }\n\n      item.obj[item.prop] = compacted;\n    }\n  }\n\n  return obj;\n};\n\nvar $LFsm$export$arrayToObject = function arrayToObject(source, options) {\n  var obj = options && options.plainObjects ? Object.create(null) : {};\n\n  for (var i = 0; i < source.length; ++i) {\n    if (typeof source[i] !== 'undefined') {\n      obj[i] = source[i];\n    }\n  }\n\n  return obj;\n};\n\n$LFsm$exports.arrayToObject = $LFsm$export$arrayToObject;\n\nvar $LFsm$export$merge = function merge(target, source, options) {\n  if (!source) {\n    return target;\n  }\n\n  if (typeof source !== 'object') {\n    if (Array.isArray(target)) {\n      target.push(source);\n    } else if (typeof target === 'object') {\n      if (options.plainObjects || options.allowPrototypes || !$LFsm$var$has.call(Object.prototype, source)) {\n        target[source] = true;\n      }\n    } else {\n      return [target, source];\n    }\n\n    return target;\n  }\n\n  if (typeof target !== 'object') {\n    return [target].concat(source);\n  }\n\n  var mergeTarget = target;\n\n  if (Array.isArray(target) && !Array.isArray(source)) {\n    mergeTarget = $LFsm$exports.arrayToObject(target, options);\n  }\n\n  if (Array.isArray(target) && Array.isArray(source)) {\n    source.forEach(function (item, i) {\n      if ($LFsm$var$has.call(target, i)) {\n        if (target[i] && typeof target[i] === 'object') {\n          target[i] = $LFsm$exports.merge(target[i], item, options);\n        } else {\n          target.push(item);\n        }\n      } else {\n        target[i] = item;\n      }\n    });\n    return target;\n  }\n\n  return Object.keys(source).reduce(function (acc, key) {\n    var value = source[key];\n\n    if ($LFsm$var$has.call(acc, key)) {\n      acc[key] = $LFsm$exports.merge(acc[key], value, options);\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, mergeTarget);\n};\n\n$LFsm$exports.merge = $LFsm$export$merge;\n\nvar $LFsm$export$assign = function assignSingleSource(target, source) {\n  return Object.keys(source).reduce(function (acc, key) {\n    acc[key] = source[key];\n    return acc;\n  }, target);\n};\n\n$LFsm$exports.assign = $LFsm$export$assign;\n\nvar $LFsm$export$decode = function (str) {\n  try {\n    return decodeURIComponent(str.replace(/\\+/g, ' '));\n  } catch (e) {\n    return str;\n  }\n};\n\n$LFsm$exports.decode = $LFsm$export$decode;\n\nvar $LFsm$export$encode = function encode(str) {\n  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n  // It has been adapted here for stricter adherence to RFC 3986\n  if (str.length === 0) {\n    return str;\n  }\n\n  var string = typeof str === 'string' ? str : String(str);\n  var out = '';\n\n  for (var i = 0; i < string.length; ++i) {\n    var c = string.charCodeAt(i);\n\n    if (c === 0x2D // -\n    || c === 0x2E // .\n    || c === 0x5F // _\n    || c === 0x7E // ~\n    || c >= 0x30 && c <= 0x39 // 0-9\n    || c >= 0x41 && c <= 0x5A // a-z\n    || c >= 0x61 && c <= 0x7A // A-Z\n    ) {\n        out += string.charAt(i);\n        continue;\n      }\n\n    if (c < 0x80) {\n      out = out + $LFsm$var$hexTable[c];\n      continue;\n    }\n\n    if (c < 0x800) {\n      out = out + ($LFsm$var$hexTable[0xC0 | c >> 6] + $LFsm$var$hexTable[0x80 | c & 0x3F]);\n      continue;\n    }\n\n    if (c < 0xD800 || c >= 0xE000) {\n      out = out + ($LFsm$var$hexTable[0xE0 | c >> 12] + $LFsm$var$hexTable[0x80 | c >> 6 & 0x3F] + $LFsm$var$hexTable[0x80 | c & 0x3F]);\n      continue;\n    }\n\n    i += 1;\n    c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);\n    out += $LFsm$var$hexTable[0xF0 | c >> 18] + $LFsm$var$hexTable[0x80 | c >> 12 & 0x3F] + $LFsm$var$hexTable[0x80 | c >> 6 & 0x3F] + $LFsm$var$hexTable[0x80 | c & 0x3F];\n  }\n\n  return out;\n};\n\n$LFsm$exports.encode = $LFsm$export$encode;\n\nvar $LFsm$export$compact = function compact(value) {\n  var queue = [{\n    obj: {\n      o: value\n    },\n    prop: 'o'\n  }];\n  var refs = [];\n\n  for (var i = 0; i < queue.length; ++i) {\n    var item = queue[i];\n    var obj = item.obj[item.prop];\n    var keys = Object.keys(obj);\n\n    for (var j = 0; j < keys.length; ++j) {\n      var key = keys[j];\n      var val = obj[key];\n\n      if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n        queue.push({\n          obj: obj,\n          prop: key\n        });\n        refs.push(val);\n      }\n    }\n  }\n\n  return $LFsm$var$compactQueue(queue);\n};\n\n$LFsm$exports.compact = $LFsm$export$compact;\n\nvar $LFsm$export$isRegExp = function isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n$LFsm$exports.isRegExp = $LFsm$export$isRegExp;\n\nvar $LFsm$export$isBuffer = function isBuffer(obj) {\n  if (obj === null || typeof obj === 'undefined') {\n    return false;\n  }\n\n  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n$LFsm$exports.isBuffer = $LFsm$export$isBuffer;"},"sourceMaps":null,"error":null,"hash":"ffaaa0a7ce1b8e72bbe008e193637e59","cacheData":{"env":{},"imports":{},"exports":{"arrayToObject":"$LFsm$export$arrayToObject","merge":"$LFsm$export$merge","assign":"$LFsm$export$assign","decode":"$LFsm$export$decode","encode":"$LFsm$export$encode","compact":"$LFsm$export$compact","isRegExp":"$LFsm$export$isRegExp","isBuffer":"$LFsm$export$isBuffer"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}