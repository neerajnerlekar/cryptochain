{"id":"HCUw","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\package.json","includedInParent":true,"mtime":1598465897439},{"name":"inherits","loc":{"line":3,"column":25},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\encoders\\der.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\inherits\\inherits_browser.js"},{"name":"safer-buffer","loc":{"line":4,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\encoders\\der.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\safer-buffer\\safer.js"},{"name":"../base/node","loc":{"line":5,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\encoders\\der.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\base\\node.js"},{"name":"../constants/der","loc":{"line":8,"column":20},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\encoders\\der.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\asn1.js\\lib\\asn1\\constants\\der.js"}],"generated":{"js":"\nvar $HCUw$exports = {};\nconst $HCUw$var$inherits = $parcel$require(\"HCUw\", \"inherits\");\nconst $HCUw$var$Buffer = $parcel$require(\"HCUw\", \"safer-buffer\").Buffer;\nconst $HCUw$var$Node = $parcel$require(\"HCUw\", \"../base/node\"); // Import DER constants\n\nconst $HCUw$var$der = $parcel$require(\"HCUw\", \"../constants/der\");\n\nfunction $HCUw$var$DEREncoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity; // Construct base tree\n\n  this.tree = new $HCUw$var$DERNode();\n\n  this.tree._init(entity.body);\n}\n\n$HCUw$exports = $HCUw$var$DEREncoder;\n\n$HCUw$var$DEREncoder.prototype.encode = function encode(data, reporter) {\n  return this.tree._encode(data, reporter).join();\n}; // Tree methods\n\n\nfunction $HCUw$var$DERNode(parent) {\n  $HCUw$var$Node.call(this, 'der', parent);\n}\n\n$HCUw$var$inherits($HCUw$var$DERNode, $HCUw$var$Node);\n\n$HCUw$var$DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {\n  const encodedTag = $HCUw$var$encodeTag(tag, primitive, cls, this.reporter); // Short form\n\n  if (content.length < 0x80) {\n    const header = $HCUw$var$Buffer.alloc(2);\n    header[0] = encodedTag;\n    header[1] = content.length;\n    return this._createEncoderBuffer([header, content]);\n  } // Long form\n  // Count octets required to store length\n\n\n  let lenOctets = 1;\n\n  for (let i = content.length; i >= 0x100; i >>= 8) lenOctets++;\n\n  const header = $HCUw$var$Buffer.alloc(1 + 1 + lenOctets);\n  header[0] = encodedTag;\n  header[1] = 0x80 | lenOctets;\n\n  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 0xff;\n\n  return this._createEncoderBuffer([header, content]);\n};\n\n$HCUw$var$DERNode.prototype._encodeStr = function encodeStr(str, tag) {\n  if (tag === 'bitstr') {\n    return this._createEncoderBuffer([str.unused | 0, str.data]);\n  } else if (tag === 'bmpstr') {\n    const buf = $HCUw$var$Buffer.alloc(str.length * 2);\n\n    for (let i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n    }\n\n    return this._createEncoderBuffer(buf);\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else if (/str$/.test(tag)) {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'objDesc') {\n    return this._createEncoderBuffer(str);\n  } else {\n    return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');\n  }\n};\n\n$HCUw$var$DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values) return this.reporter.error('string objid given, but no values map found');\n    if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');\n    id = values[id].split(/[\\s.]+/g);\n\n    for (let i = 0; i < id.length; i++) id[i] |= 0;\n  } else if (Array.isArray(id)) {\n    id = id.slice();\n\n    for (let i = 0; i < id.length; i++) id[i] |= 0;\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));\n  }\n\n  if (!relative) {\n    if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');\n    id.splice(0, 2, id[0] * 40 + id[1]);\n  } // Count number of octets\n\n\n  let size = 0;\n\n  for (let i = 0; i < id.length; i++) {\n    let ident = id[i];\n\n    for (size++; ident >= 0x80; ident >>= 7) size++;\n  }\n\n  const objid = $HCUw$var$Buffer.alloc(size);\n  let offset = objid.length - 1;\n\n  for (let i = id.length - 1; i >= 0; i--) {\n    let ident = id[i];\n    objid[offset--] = ident & 0x7f;\n\n    while ((ident >>= 7) > 0) objid[offset--] = 0x80 | ident & 0x7f;\n  }\n\n  return this._createEncoderBuffer(objid);\n};\n\nfunction $HCUw$var$two(num) {\n  if (num < 10) return '0' + num;else return num;\n}\n\n$HCUw$var$DERNode.prototype._encodeTime = function encodeTime(time, tag) {\n  let str;\n  const date = new Date(time);\n\n  if (tag === 'gentime') {\n    str = [$HCUw$var$two(date.getUTCFullYear()), $HCUw$var$two(date.getUTCMonth() + 1), $HCUw$var$two(date.getUTCDate()), $HCUw$var$two(date.getUTCHours()), $HCUw$var$two(date.getUTCMinutes()), $HCUw$var$two(date.getUTCSeconds()), 'Z'].join('');\n  } else if (tag === 'utctime') {\n    str = [$HCUw$var$two(date.getUTCFullYear() % 100), $HCUw$var$two(date.getUTCMonth() + 1), $HCUw$var$two(date.getUTCDate()), $HCUw$var$two(date.getUTCHours()), $HCUw$var$two(date.getUTCMinutes()), $HCUw$var$two(date.getUTCSeconds()), 'Z'].join('');\n  } else {\n    this.reporter.error('Encoding ' + tag + ' time is not supported yet');\n  }\n\n  return this._encodeStr(str, 'octstr');\n};\n\n$HCUw$var$DERNode.prototype._encodeNull = function encodeNull() {\n  return this._createEncoderBuffer('');\n};\n\n$HCUw$var$DERNode.prototype._encodeInt = function encodeInt(num, values) {\n  if (typeof num === 'string') {\n    if (!values) return this.reporter.error('String int or enum given, but no values map');\n\n    if (!values.hasOwnProperty(num)) {\n      return this.reporter.error('Values map doesn\\'t contain: ' + JSON.stringify(num));\n    }\n\n    num = values[num];\n  } // Bignum, assume big endian\n\n\n  if (typeof num !== 'number' && !$HCUw$var$Buffer.isBuffer(num)) {\n    const numArray = num.toArray();\n\n    if (!num.sign && numArray[0] & 0x80) {\n      numArray.unshift(0);\n    }\n\n    num = $HCUw$var$Buffer.from(numArray);\n  }\n\n  if ($HCUw$var$Buffer.isBuffer(num)) {\n    let size = num.length;\n    if (num.length === 0) size++;\n    const out = $HCUw$var$Buffer.alloc(size);\n    num.copy(out);\n    if (num.length === 0) out[0] = 0;\n    return this._createEncoderBuffer(out);\n  }\n\n  if (num < 0x80) return this._createEncoderBuffer(num);\n  if (num < 0x100) return this._createEncoderBuffer([0, num]);\n  let size = 1;\n\n  for (let i = num; i >= 0x100; i >>= 8) size++;\n\n  const out = new Array(size);\n\n  for (let i = out.length - 1; i >= 0; i--) {\n    out[i] = num & 0xff;\n    num >>= 8;\n  }\n\n  if (out[0] & 0x80) {\n    out.unshift(0);\n  }\n\n  return this._createEncoderBuffer($HCUw$var$Buffer.from(out));\n};\n\n$HCUw$var$DERNode.prototype._encodeBool = function encodeBool(value) {\n  return this._createEncoderBuffer(value ? 0xff : 0);\n};\n\n$HCUw$var$DERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function') entity = entity(obj);\n  return entity._getEncoder('der').tree;\n};\n\n$HCUw$var$DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\n  const state = this._baseState;\n  let i;\n  if (state['default'] === null) return false;\n  const data = dataBuffer.join();\n  if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();\n  if (data.length !== state.defaultBuffer.length) return false;\n\n  for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;\n\n  return true;\n}; // Utility methods\n\n\nfunction $HCUw$var$encodeTag(tag, primitive, cls, reporter) {\n  let res;\n  if (tag === 'seqof') tag = 'seq';else if (tag === 'setof') tag = 'set';\n  if ($HCUw$var$der.tagByName.hasOwnProperty(tag)) res = $HCUw$var$der.tagByName[tag];else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;else return reporter.error('Unknown tag: ' + tag);\n  if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported');\n  if (!primitive) res |= 0x20;\n  res |= $HCUw$var$der.tagClassByName[cls || 'universal'] << 6;\n  return res;\n}"},"sourceMaps":null,"error":null,"hash":"b28d2caae6456f85647a18346b393dd1","cacheData":{"env":{},"imports":{"$require$inherits":["inherits","*"],"$require$safer-buffer":["safer-buffer","*"],"$require$../base/node":["../base/node","*"],"$require$../constants/der":["../constants/der","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}