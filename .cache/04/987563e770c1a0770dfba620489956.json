{"id":"rH1J","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\package.json","includedInParent":true,"mtime":1598465901818}],"generated":{"js":"\nvar $rH1J$exports = {};\n// shim for using process in browser\nvar $rH1J$var$process = $rH1J$exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar $rH1J$var$cachedSetTimeout;\nvar $rH1J$var$cachedClearTimeout;\n\nfunction $rH1J$var$defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction $rH1J$var$defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      $rH1J$var$cachedSetTimeout = setTimeout;\n    } else {\n      $rH1J$var$cachedSetTimeout = $rH1J$var$defaultSetTimout;\n    }\n  } catch (e) {\n    $rH1J$var$cachedSetTimeout = $rH1J$var$defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      $rH1J$var$cachedClearTimeout = clearTimeout;\n    } else {\n      $rH1J$var$cachedClearTimeout = $rH1J$var$defaultClearTimeout;\n    }\n  } catch (e) {\n    $rH1J$var$cachedClearTimeout = $rH1J$var$defaultClearTimeout;\n  }\n})();\n\nfunction $rH1J$var$runTimeout(fun) {\n  if ($rH1J$var$cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if (($rH1J$var$cachedSetTimeout === $rH1J$var$defaultSetTimout || !$rH1J$var$cachedSetTimeout) && setTimeout) {\n    $rH1J$var$cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $rH1J$var$cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return $rH1J$var$cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return $rH1J$var$cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction $rH1J$var$runClearTimeout(marker) {\n  if ($rH1J$var$cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if (($rH1J$var$cachedClearTimeout === $rH1J$var$defaultClearTimeout || !$rH1J$var$cachedClearTimeout) && clearTimeout) {\n    $rH1J$var$cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $rH1J$var$cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return $rH1J$var$cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return $rH1J$var$cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar $rH1J$var$queue = [];\nvar $rH1J$var$draining = false;\nvar $rH1J$var$currentQueue;\nvar $rH1J$var$queueIndex = -1;\n\nfunction $rH1J$var$cleanUpNextTick() {\n  if (!$rH1J$var$draining || !$rH1J$var$currentQueue) {\n    return;\n  }\n\n  $rH1J$var$draining = false;\n\n  if ($rH1J$var$currentQueue.length) {\n    $rH1J$var$queue = $rH1J$var$currentQueue.concat($rH1J$var$queue);\n  } else {\n    $rH1J$var$queueIndex = -1;\n  }\n\n  if ($rH1J$var$queue.length) {\n    $rH1J$var$drainQueue();\n  }\n}\n\nfunction $rH1J$var$drainQueue() {\n  if ($rH1J$var$draining) {\n    return;\n  }\n\n  var timeout = $rH1J$var$runTimeout($rH1J$var$cleanUpNextTick);\n  $rH1J$var$draining = true;\n  var len = $rH1J$var$queue.length;\n\n  while (len) {\n    $rH1J$var$currentQueue = $rH1J$var$queue;\n    $rH1J$var$queue = [];\n\n    while (++$rH1J$var$queueIndex < len) {\n      if ($rH1J$var$currentQueue) {\n        $rH1J$var$currentQueue[$rH1J$var$queueIndex].run();\n      }\n    }\n\n    $rH1J$var$queueIndex = -1;\n    len = $rH1J$var$queue.length;\n  }\n\n  $rH1J$var$currentQueue = null;\n  $rH1J$var$draining = false;\n  $rH1J$var$runClearTimeout(timeout);\n}\n\n$rH1J$var$process.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  $rH1J$var$queue.push(new $rH1J$var$Item(fun, args));\n\n  if ($rH1J$var$queue.length === 1 && !$rH1J$var$draining) {\n    $rH1J$var$runTimeout($rH1J$var$drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction $rH1J$var$Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\n$rH1J$var$Item.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\n$rH1J$var$process.title = 'browser';\n$rH1J$var$process.env = {};\n$rH1J$var$process.argv = [];\n$rH1J$var$process.version = ''; // empty string to avoid regexp issues\n\n$rH1J$var$process.versions = {};\n\nfunction $rH1J$var$noop() {}\n\n$rH1J$var$process.on = $rH1J$var$noop;\n$rH1J$var$process.addListener = $rH1J$var$noop;\n$rH1J$var$process.once = $rH1J$var$noop;\n$rH1J$var$process.off = $rH1J$var$noop;\n$rH1J$var$process.removeListener = $rH1J$var$noop;\n$rH1J$var$process.removeAllListeners = $rH1J$var$noop;\n$rH1J$var$process.emit = $rH1J$var$noop;\n$rH1J$var$process.prependListener = $rH1J$var$noop;\n$rH1J$var$process.prependOnceListener = $rH1J$var$noop;\n\n$rH1J$var$process.listeners = function (name) {\n  return [];\n};\n\n$rH1J$var$process.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\n$rH1J$var$process.cwd = function () {\n  return '/';\n};\n\n$rH1J$var$process.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\n$rH1J$var$process.umask = function () {\n  return 0;\n};"},"sourceMaps":null,"error":null,"hash":"be6ba31ef63fef346b90cb17e897c9de","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}