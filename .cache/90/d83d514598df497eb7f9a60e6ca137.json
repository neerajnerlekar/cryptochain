{"id":"AxMc","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\proxy-addr\\package.json","includedInParent":true,"mtime":1598465901644},{"name":"forwarded","loc":{"line":23,"column":24},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\proxy-addr\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\forwarded\\index.js"},{"name":"ipaddr.js","loc":{"line":24,"column":21},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\proxy-addr\\index.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\ipaddr.js\\lib\\ipaddr.js"}],"generated":{"js":"var $AxMc$exports = {};\n\n/**\n * Module exports.\n * @public\n */\n$AxMc$exports = $AxMc$var$proxyaddr;\n$AxMc$exports.all = $AxMc$var$alladdrs;\n$AxMc$exports.compile = $AxMc$var$compile;\n/**\n * Module dependencies.\n * @private\n */\n\nvar $AxMc$var$forwarded = $parcel$require(\"AxMc\", \"forwarded\");\nvar $AxMc$var$ipaddr = $parcel$require(\"AxMc\", \"ipaddr.js\");\n/**\n * Variables.\n * @private\n */\n\nvar $AxMc$var$DIGIT_REGEXP = /^[0-9]+$/;\nvar $AxMc$var$isip = $AxMc$var$ipaddr.isValid;\nvar $AxMc$var$parseip = $AxMc$var$ipaddr.parse;\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar $AxMc$var$IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction $AxMc$var$alladdrs(req, trust) {\n  // get addresses\n  var addrs = $AxMc$var$forwarded(req);\n\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n\n  if (typeof trust !== 'function') {\n    trust = $AxMc$var$compile(trust);\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n\n  return addrs;\n}\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\n\nfunction $AxMc$var$compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n\n  var trust;\n\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n\n    if (!Object.prototype.hasOwnProperty.call($AxMc$var$IP_RANGES, val)) {\n      continue;\n    } // Splice in pre-defined range\n\n\n    val = $AxMc$var$IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n\n  return $AxMc$var$compileTrust($AxMc$var$compileRangeSubnets(trust));\n}\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\n\nfunction $AxMc$var$compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = $AxMc$var$parseipNotation(arr[i]);\n  }\n\n  return rangeSubnets;\n}\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\n\nfunction $AxMc$var$compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0 ? $AxMc$var$trustNone : len === 1 ? $AxMc$var$trustSingle(rangeSubnets[0]) : $AxMc$var$trustMulti(rangeSubnets);\n}\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\n\nfunction $AxMc$var$parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n\n  if (!$AxMc$var$isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n\n  var ip = $AxMc$var$parseip(str);\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n\n  if (range === null) {\n    range = max;\n  } else if ($AxMc$var$DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && $AxMc$var$isip(range)) {\n    range = $AxMc$var$parseNetmask(range);\n  } else {\n    range = null;\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n\n  return [ip, range];\n}\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\n\nfunction $AxMc$var$parseNetmask(netmask) {\n  var ip = $AxMc$var$parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\n\nfunction $AxMc$var$proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n\n  var addrs = $AxMc$var$alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\n\nfunction $AxMc$var$trustNone() {\n  return false;\n}\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\n\nfunction $AxMc$var$trustMulti(subnets) {\n  return function trust(addr) {\n    if (!$AxMc$var$isip(addr)) return false;\n    var ip = $AxMc$var$parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n\n        trusted = ipconv;\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\n\nfunction $AxMc$var$trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!$AxMc$var$isip(addr)) return false;\n    var ip = $AxMc$var$parseip(addr);\n    var kind = ip.kind();\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      } // Convert IP to match subnet IP kind\n\n\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n\n    return ip.match(subnetip, subnetrange);\n  };\n}"},"sourceMaps":null,"error":null,"hash":"173276c3be0667af9a6acdf2500a3c05","cacheData":{"env":{},"imports":{"$require$forwarded":["forwarded","*"],"$require$ipaddr.js":["ipaddr.js","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}