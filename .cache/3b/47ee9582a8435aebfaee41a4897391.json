{"id":"LNnP","dependencies":[{"name":"F:\\Programs\\bbc\\cryptochain\\package.json","includedInParent":true,"mtime":1598477104553},{"name":"F:\\Programs\\bbc\\cryptochain\\.babelrc","includedInParent":true,"mtime":1598465557409},{"name":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\package.json","includedInParent":true,"mtime":1598465887062},{"name":"./end-of-stream","loc":{"line":7,"column":23},"parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js"},{"name":"process","parent":"F:\\Programs\\bbc\\cryptochain\\node_modules\\hash-base\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js","resolved":"F:\\Programs\\bbc\\cryptochain\\node_modules\\process\\browser.js"}],"generated":{"js":"var $LNnP$exports = {};\nvar $LNnP$var$process = $parcel$require(\"LNnP\", \"process\");\nvar $LNnP$var$_Object$setPrototypeO;\n\nfunction $LNnP$var$_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar $LNnP$var$finished = $parcel$require(\"LNnP\", \"./end-of-stream\");\nvar $LNnP$var$kLastResolve = Symbol('lastResolve');\nvar $LNnP$var$kLastReject = Symbol('lastReject');\nvar $LNnP$var$kError = Symbol('error');\nvar $LNnP$var$kEnded = Symbol('ended');\nvar $LNnP$var$kLastPromise = Symbol('lastPromise');\nvar $LNnP$var$kHandlePromise = Symbol('handlePromise');\nvar $LNnP$var$kStream = Symbol('stream');\n\nfunction $LNnP$var$createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction $LNnP$var$readAndResolve(iter) {\n  var resolve = iter[$LNnP$var$kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[$LNnP$var$kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[$LNnP$var$kLastPromise] = null;\n      iter[$LNnP$var$kLastResolve] = null;\n      iter[$LNnP$var$kLastReject] = null;\n      resolve($LNnP$var$createIterResult(data, false));\n    }\n  }\n}\n\nfunction $LNnP$var$onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  $LNnP$var$process.nextTick($LNnP$var$readAndResolve, iter);\n}\n\nfunction $LNnP$var$wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[$LNnP$var$kEnded]) {\n        resolve($LNnP$var$createIterResult(undefined, true));\n        return;\n      }\n\n      iter[$LNnP$var$kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar $LNnP$var$AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar $LNnP$var$ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(($LNnP$var$_Object$setPrototypeO = {\n  get stream() {\n    return this[$LNnP$var$kStream];\n  },\n\n  next: function next() {\n    var _this = this; // if we have detected an error in the meanwhile\n    // reject straight away\n\n\n    var error = this[$LNnP$var$kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[$LNnP$var$kEnded]) {\n      return Promise.resolve($LNnP$var$createIterResult(undefined, true));\n    }\n\n    if (this[$LNnP$var$kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        $LNnP$var$process.nextTick(function () {\n          if (_this[$LNnP$var$kError]) {\n            reject(_this[$LNnP$var$kError]);\n          } else {\n            resolve($LNnP$var$createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[$LNnP$var$kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise($LNnP$var$wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[$LNnP$var$kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve($LNnP$var$createIterResult(data, false));\n      }\n\n      promise = new Promise(this[$LNnP$var$kHandlePromise]);\n    }\n\n    this[$LNnP$var$kLastPromise] = promise;\n    return promise;\n  }\n}, $LNnP$var$_defineProperty($LNnP$var$_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), $LNnP$var$_defineProperty($LNnP$var$_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this; // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n\n\n  return new Promise(function (resolve, reject) {\n    _this2[$LNnP$var$kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve($LNnP$var$createIterResult(undefined, true));\n    });\n  });\n}), $LNnP$var$_Object$setPrototypeO), $LNnP$var$AsyncIteratorPrototype);\n\nvar $LNnP$var$createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create($LNnP$var$ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kStream, {\n    value: stream,\n    writable: true\n  }), $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kLastResolve, {\n    value: null,\n    writable: true\n  }), $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kLastReject, {\n    value: null,\n    writable: true\n  }), $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kError, {\n    value: null,\n    writable: true\n  }), $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), $LNnP$var$_defineProperty(_Object$create, $LNnP$var$kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[$LNnP$var$kStream].read();\n\n      if (data) {\n        iterator[$LNnP$var$kLastPromise] = null;\n        iterator[$LNnP$var$kLastResolve] = null;\n        iterator[$LNnP$var$kLastReject] = null;\n        resolve($LNnP$var$createIterResult(data, false));\n      } else {\n        iterator[$LNnP$var$kLastResolve] = resolve;\n        iterator[$LNnP$var$kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[$LNnP$var$kLastPromise] = null;\n  $LNnP$var$finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[$LNnP$var$kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[$LNnP$var$kLastPromise] = null;\n        iterator[$LNnP$var$kLastResolve] = null;\n        iterator[$LNnP$var$kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[$LNnP$var$kError] = err;\n      return;\n    }\n\n    var resolve = iterator[$LNnP$var$kLastResolve];\n\n    if (resolve !== null) {\n      iterator[$LNnP$var$kLastPromise] = null;\n      iterator[$LNnP$var$kLastResolve] = null;\n      iterator[$LNnP$var$kLastReject] = null;\n      resolve($LNnP$var$createIterResult(undefined, true));\n    }\n\n    iterator[$LNnP$var$kEnded] = true;\n  });\n  stream.on('readable', $LNnP$var$onReadable.bind(null, iterator));\n  return iterator;\n};\n\n$LNnP$exports = $LNnP$var$createReadableStreamAsyncIterator;"},"sourceMaps":null,"error":null,"hash":"ef17ef2273ffa610f3c39376acb616cc","cacheData":{"env":{},"imports":{"$require$./end-of-stream":["./end-of-stream","*"],"$require$process":["process","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true,"shouldWrap":true}}